# معماری

![Bloc Architecture](assets/bloc_architecture_full.png)

استفاده از کتابخانه Bloc به ما این امکان را می دهد که برنامه را به سه لایه جدا کنیم:

- ارائه
- لاجیک (منطق کسب و کار)
- داده
  - مخزن (Repository)
  - ارائه دهنده داده (Data Provider)

ما قصد داریم از لایه پایین‌ترین (دورترین از رابط کاربری) شروع کنیم و به سمت لایه ارائه حرکت کنیم.

## لایه داده

> مسئولیت لایه داده بازیابی/دستکاری داده ها از یک یا چند منبع است.

لایه داده را می توان به دو بخش تقسیم کرد:

- مخزن (Repository)
- ارائه دهنده داده (Data Provider)

این لایه پایین ترین سطح برنامه است و با پایگاه  داده، درخواست های شبکه و سایر منابع داده ناهمزمان (Asynchronous data sources) تعامل دارد.

### ارائه دهنده داده

> مسئولیت ارائه دهنده داده، ارائه داده های خام است. ارائه دهنده داده باید عمومی (Generic) و انعطاف پذیر باشد.

ارائه‌دهنده داده معمولاً، API های ساده را برای انجام عملیات [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) فراهم خواهد کرد.
ممکن است ما دارای متدهایی با نام‌های `createData`، `readData`، `updateData` و `deleteData` به عنوان بخشی از لایه داده باشیم.

[data_provider.dart](_snippets/architecture/data_provider.dart.md ':include')

### مخزن

> لایه مخزن (Repository) یک پوشش (Wrapper) بر روی یک یا چند ارائه‌دهنده داده (Data provider) است که لایه Bloc با آن ارتباط برقرار می کند.

[repository.dart](_snippets/architecture/repository.dart.md ':include')

همانطور که می بینید، لایه مخزن ما می تواند با چندین ارائه دهنده داده تعامل داشته باشد و قبل از اینکه نتیجه را به لایه لاجیک تحویل دهد، روی داده ها تغییر شکل دهد.

## لایه لاجیک یا منطق کسب و کار

> مسئولیت لایه منطق کسب‌وکار پاسخگویی به ورودی‌های لایه ارائه با وضعیت‌های جدید است. این لایه ممکن است به یک یا چند مخزن وابسته باشد تا داده‌های مورد نیاز برای ساخت وضعیت برنامه را دریافت کند.

لایه منطق کسب‌وکار را به عنوان پلی بین رابط کاربری (لایه ارائه) و لایه داده در نظر بگیرید. لایه منطق کسب‌وکار از رویدادها (Events) / اقدامات (Actions) لایه ارائه مطلع می‌شود و سپس با مخزن ارتباط برقرار می کند تا یک حالت جدید برای لایه ارائه ایجاد کند.

[business_logic_component.dart](_snippets/architecture/business_logic_component.dart.md ':include')

### ارتباط Bloc با Bloc

به دلیل آنکه Bloc ها جریان‌ها (Streams) را فراهم می‌کنند، ممکن است وسوسه انگیز باشد که Bloc بسازیم که به Bloc دیگری گوش دهد. شما نباید **نباید** این کار را انجام دهید. جایگزین های بهتری نسبت به کد زیر وجود دارد:

[do_not_do_this_at_home.dart](_snippets/architecture/do_not_do_this_at_home.dart.md ':include')

اگرچه کد فوق بدون خطا است (و حتی پس از اجرا کارهای، به تمیز کردن و بستن جریان ها نیز می‌پردازد)، اما یک مشکل بزرگ‌تر دارد و آن وابستگی بین دو Bloc است.

بطور کلی، وابستگی‌های هم‌سطح (Sibling dependencies) بین دو موجودیت (Entities) در یک لایه معماری باید با هر قیمتی اجتناب شود، زیرا این وابستگی‌ها باعث اتصال زنجیره‌ای می‌شوند که نگهداری (Maintain) را دشوار میکند. از آنجا که Bloc ها در لایه معماری منطق کسب‌وکار قرار دارند، هیچ Bloc نباید درباره Bloc دیگری اطلاع داشته باشد.

![Application Architecture Layers](assets/architecture.png)

یک Bloc فقط باید اطلاعات را از طریق رویدادها (Events) و از مخازن تزریق‌شده (به عنوان مثال، مخازنی که در زمان ساخت Bloc به آن داده شده) دریافت کند.

اگر در شرایطی هستید که یک Bloc باید به یک Bloc دیگر پاسخ دهد، دو گزینه دیگر دارید. می‌توانید مشکل را به بالاترین لایه (در لایه ارائه) منتقل کنید یا به پایین‌ترین لایه (در لایه دامنه) انتقال دهید.

#### اتصال Bloc ها از طریق لایه ارائه

می‌توانید از `BlocListener` استفاده کنید تا به یک Bloc گوش داده و هر زمان که Bloc اول تغییر کند، یک رویداد به Bloc دیگر اضافه کنید.

[blocs_presentation.dart.md](_snippets/architecture/blocs_presentation.dart.md ':include')

کد بالا از نیاز `SecondBloc` به دانستن در مورد `FirstBloc` جلوگیری می‌کند و تشویق به اتصال گسسته (loose-coupling) می‌کند. اپلیکیشن [flutter_weather](flutterweathertutorial.md) از این [تکنیک استفاده می‌کند](https://github.com/felangel/bloc/blob/b4c8db938ad71a6b60d4a641ec357905095c3965/examples/flutter_weather/lib/weather/view/weather_page.dart#L38-L42) تا بر اساس اطلاعات هواشناسی دریافتی، پوسته برنامه را تغییر دهد.

در برخی مواقع، ممکن است نخواهید که دو Bloc در لایه ارائه به یکدیگر وابسته باشند. در عوض، اغلب منطقی است که دو Bloc از یک منبع مشترک داده استفاده کنند و هر زمان که داده تغییر می کند به روز شوند.

#### اتصال Bloc ها از طریق دامنه

دو Bloc می‌توانند به جریانی از یک مخزن (Repository) گوش دهند و هر زمان که داده‌های مخزن تغییر کند، وضعیت‌های خود را مستقل از یکدیگر به‌روزرسانی کنند. استفاده از مخازن واکنشی (Reactive repositories) برای هماهنگ نگه داشتن حالت در برنامه های سازمانی در مقیاس بزرگ رایج است.

اولین گام، ایجاد یک مخزن (Repository) یا استفاده از یک مخزن است که یک جریان داده (`Stream`) فراهم می‌کند. به عنوان مثال، مخزن زیر یک جریان داده بی‌پایان (Never-ending stream) از چند ایده برنامه مشابه ارائه می‌دهد:

[app_ideas_repo.dart.md](_snippets/architecture/app_ideas_repo.dart.md ':include')

همان مخزن (Repository) را می توان در هر Bloc ای که نیاز به واکنش به ایده های جدید برنامه دارد، تزریق کرد. در زیر یک `AppIdeaRankingBloc` وجود دارد که برای هر ایده برنامه جدیدی که از مخزن بالا می رسد، یک وضعیت (State) تولید می کند(به کمک yields):

[blocs_domain.dart.md](_snippets/architecture/blocs_domain.dart.md ':include')

برای اطلاعات بیشتر در مورد استفاده از جریان با Bloc به [نحوه استفاده از بلوک با جریان و همزمانی](https://verygood.ventures/blog/how-to-use-bloc-with-streams-and-concurrency) مراجعه کنید.

## لایه ارائه

> مسئوليت لایه‌ی ارائه این است که بر اساس یک یا چند حالت Bloc بفهمد، چگونه خود را نمایش دهد. علاوه بر این، باید ورودی کاربر و رویدادهای چرخه‌ی عمر برنامه را مدیریت کند.

بیشتر جریان های اپلیکیشن ها با یک رویداد با نام `AppStart` آغاز می‌شوند که باعث می‌شود برنامه اطلاعاتی را دریافت کند تا به کاربر ارائه دهد.

در این سناریو، لایه ارائه یک رویداد `AppStart` را اضافه می کند.

علاوه بر این، لایه ارائه باید بفهمد که بر اساس وضعیت لایه بلوک، چه چیزی روی صفحه نمایش داده می شود.

[presentation_component.dart](_snippets/architecture/presentation_component.dart.md ':include')

تا اینجا، اگرچه ما چند قطعه کد داشته ایم، اما همه اینها در سطح نسبتاً بالایی بوده است. در بخش آموزش، ما همه اینها را در کنار هم قرار می دهیم و چندین برنامه نمونه مختلف را می سازیم.
