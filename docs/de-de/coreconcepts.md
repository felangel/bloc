# Grundlegende Konzepte (package:bloc)

?> Bitte lesen Sie die folgenden Abschnitte sorgf√§ltig durch, bevor Sie mit [package:bloc](https://pub.dev/packages/bloc) arbeiten.

Es gibt mehrere Kernkonzepte, die f√ºr das Verst√§ndnis der Verwendung des bloc-Pakets entscheidend sind.

In den folgenden Abschnitten werden wir jedes von ihnen im Detail besprechen und durcharbeiten, wie sie auf eine Counter-Anwendung angewendet werden k√∂nnen.

## Streams

?> In der offiziellen [Dart-Dokumentation](https://dart.dev/tutorials/language/streams) finden Sie weitere Informationen √ºber `Streams`.

> Ein Stream ist eine Folge von asynchronen Daten.

Um die bloc-Bibliothek nutzen zu k√∂nnen, ist es wichtig, ein grundlegendes Verst√§ndnis von `Streams` und deren Funktionsweise zu haben.

> Wenn Sie mit `Streams` nicht vertraut sind, stellen Sie sich einfach ein Rohr vor, durch das Wasser flie√üt. Das Rohr ist der `Stream` und das flie√üende Wasser sind die asynchronen Daten.

Wir k√∂nnen einen `Stream` in Dart erstellen, indem wir eine `async*`-Funktion (asynchroner Generator) schreiben.

[count_stream.dart](../_snippets/core_concepts/count_stream.dart.md ':include')

Indem wir eine Funktion als `async*` kennzeichnen, k√∂nnen wir das Schl√ºsselwort `yield` verwenden und einen `Stream` von Daten zur√ºckgeben. In dem obigen Beispiel geben wir einen `Stream` von Ganzzahlen bis zum Parameter `max` zur√ºck.

Jedes Mal, wenn wir das Schl√ºsselwort `yield` in einer `async*`-Funktion verwenden, schieben wir diese Dateneinheit durch den `Stream`.

Wir k√∂nnen den obigen `Stream` auf verschiedene Arten nutzen. Wenn wir eine Funktion schreiben wollten, die die Summe eines `Streams` von Ganzzahlen zur√ºckgibt, k√∂nnte sie etwa so aussehen:

[sum_stream.dart](../_snippets/core_concepts/sum_stream.dart.md ':include')

Indem wir die obige Funktion als `async` kennzeichnen, k√∂nnen wir das Schl√ºsselwort `await` verwenden und eine `Future` mit ganzen Zahlen zur√ºckgeben. In diesem Beispiel warten wir auf jeden Wert im Stream und geben die Summe aller Ganzzahlen im Stream zur√ºck.

Wir k√∂nnen das alles so zusammensetzen:

[main.dart](../_snippets/core_concepts/streams_main.dart.md ':include')

Nachdem wir nun ein grundlegendes Verst√§ndnis davon haben, wie `Streams` in Dart funktionieren, sind wir bereit, etwas √ºber die Kernkomponente des bloc-Pakets zu lernen: einen `Cubit`.

## Cubit

> Ein `Cubit` ist eine Klasse, die `BlocBase` erweitert und zur Verwaltung jeder Art von Zustand erweitert werden kann.

![Cubit Architecture](assets/cubit_architecture_full.png)

Ein `Cubit` kann Funktionen bereitstellen, die aufgerufen werden k√∂nnen, um Zustands√§nderungen auszul√∂sen.

> Zust√§nde sind die Ausgaben eines `Cubits` und stellen einen Teil des Zustands Ihrer Anwendung dar. UI-Komponenten k√∂nnen √ºber Zust√§nde benachrichtigt werden und Teile von sich selbst, basierend auf dem aktuellen Zustand, neu zeichnen.

> **Hinweis**: Weitere Informationen √ºber die Urspr√ºnge von `Cubit` finden Sie [im folgenden Link](https://github.com/felangel/cubit/issues/69).

### Erstellen eines Cubits

Wir k√∂nnen ein `CounterCubit` wie folgt erstellen:

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit.dart.md ':include')

Bei der Erstellung eines `Cubits` m√ºssen wir den Typ des Zustands definieren, den der `Cubit` verwalten wird. Im Fall des obigen `CounterCubit` kann der Zustand durch einen `int` dargestellt werden, aber in komplexeren F√§llen k√∂nnte es notwendig sein, eine Klasse `class` anstelle eines primitiven Typs zu verwenden.

Die zweite Sache, die wir tun m√ºssen, wenn wir einen `Cubit` erstellen, ist, den Anfangszustand festzulegen. Wir k√∂nnen dies tun, indem wir `super` mit dem Wert des Anfangszustandes aufrufen. Im obigen Schnipsel setzen wir den Anfangszustand intern auf `0`, aber wir k√∂nnen dem `Cubit` auch erlauben, flexibler zu sein, indem wir einen externen Wert akzeptieren:

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit_initial_state.dart.md ':include')

Dies w√ºrde es uns erm√∂glichen, `CounterCubit`-Instanzen mit verschiedenen Ausgangszust√§nden zu instanziieren:

[main.dart](../_snippets/core_concepts/counter_cubit_instantiation.dart.md ':include')

### Zustands√§nderungen

> Jeder `Cubit` hat die F√§higkeit, einen neuen Zustand √ºber `emit` auszugeben.

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit_increment.dart.md ':include')

Im obigen Ausschnitt stellt der `CounterCubit` eine √∂ffentliche Methode namens `increment` zur Verf√ºgung, die von au√üen aufgerufen werden kann, um dem `CounterCubit` mitzuteilen, dass sein Zustand erh√∂ht werden soll. Wenn `increment` aufgerufen wird, k√∂nnen wir √ºber den Getter `state` auf den aktuellen Zustand des `Cubit` zugreifen und einen neuen Zustand emittieren `emit`, indem wir eine 1 zum aktuellen Zustand addieren.

!> Die Methode `emit` ist gesch√ºtzt, d.h. sie sollte nur innerhalb eines `Cubits` verwendet werden.

### Verwendung eines Cubits

Jetzt k√∂nnen wir den `CounterCubit`, den wir implementiert haben, verwenden!

#### Grundlegende Verwendung

[main.dart](../_snippets/core_concepts/counter_cubit_basic_usage.dart.md ':include')

Im obigen Ausschnitt wird zun√§chst eine Instanz des `CounterCubits` erstellt. Dann geben wir den aktuellen Zustand des Cubits aus, der den Anfangszustand darstellt, da noch keine neuen Zust√§nde emittiert wurden. Als n√§chstes rufen wir die Funktion `increment` auf, um eine Zustands√§nderung auszul√∂sen. Zum Schluss geben wir den Zustand des Cubits aus, der von `0` auf `1` gewechselt hat und schlie√üen den Cubit, um den internen Zustandsstrom zu schlie√üen.

#### Stream Verwendung

Da ein `Cubit` ein spezieller Typ von `Stream` ist, k√∂nnen wir auch einen `Cubit` abonnieren bzw. subscriben, um seinen Zustand in Echtzeit zu aktualisieren:

[main.dart](../_snippets/core_concepts/counter_cubit_stream_usage.dart.md ':include')

In dem obigen Ausschnitt abonnieren wir den `CounterCubit` und rufen bei jeder Zustands√§nderung `print` auf. Dann rufen wir die Funktion `increment` auf, die einen neuen Zustand ausgibt. Schlie√ülich rufen wir die Methode `cancel` von der `subscription` auf, wenn wir keine Aktualisierungen mehr erhalten wollen und schlie√üen den `Cubit`.

?> **Hinweis**: `await Future.delayed(Duration.zero)` wird f√ºr dieses Beispiel hinzugef√ºgt, um zu vermeiden, dass die `subscription` sofort gek√ºndigt wird.

!> Nur nachfolgende Zustands√§nderungen werden beim Aufruf von `listen` auf einem `Cubit` empfangen.

### Beobachten eines Cubits

> Wenn ein `Cubit` einen neuen Zustand ausgibt, findet eine `Change` statt. Wir k√∂nnen alle √Ñnderungen f√ºr einen bestimmten `Cubit` beobachten, indem wir `onChange` √ºberschreiben.

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit_on_change.dart.md ':include')

Wir k√∂nnen dann mit dem `Cubit` interagieren und alle √Ñnderungen auf der Konsole beobachten.

[main.dart](../_snippets/core_concepts/counter_cubit_on_change_usage.dart.md ':include')

Das obige Beispiel w√ºrde folgendes ausgeben:

[script](../_snippets/core_concepts/counter_cubit_on_change_output.sh.md ':include')

?> **Hinweis**: Eine `Change` erfolgt kurz bevor der Zustand des `Cubits` aktualisiert wird. Eine `Change` besteht aus dem `currentState` und dem `nextState`.

#### BlocObserver

Ein zus√§tzlicher Bonus bei der Verwendung der bloc-Bibliothek ist, dass wir an einer Stelle Zugriff auf alle `Changes` haben. Auch wenn wir in dieser Anwendung nur einen `Cubit` haben, ist es in gr√∂√üeren Anwendungen √ºblich, viele `Cubits` zu haben, die verschiedene Teile des Anwendungsstatus verwalten.

Wenn wir in der Lage sein wollen, etwas als Reaktion auf alle `Changes` zu tun, k√∂nnen wir einfach unseren eigenen `BlocObserver` erstellen.

[simple_bloc_observer_on_change.dart](../_snippets/core_concepts/simple_bloc_observer_on_change.dart.md ':include')

?> **Hinweis**: Alles, was wir tun m√ºssen, ist den `BlocObserver` zu erweitern bzw. extenden und die Methode `onChange` √ºberschreiben bzw. overriden.

Um den `SimpleBlocObserver` zu verwenden, m√ºssen wir nur die `main` Funktion anpassen:

[main.dart](../_snippets/core_concepts/simple_bloc_observer_on_change_usage.dart.md ':include')

Das obige Snippet w√ºrde dann folgendes ausgeben:

[script](../_snippets/core_concepts/counter_cubit_on_change_usage_output.sh.md ':include')

?> **Hinweis**: Die interne `onChange`-√úberschreibung (override) wird zuerst aufgerufen, gefolgt von `onChange` in `BlocObserver`.

?> üí° **Tipp**: In `BlocObserver` haben wir Zugriff auf die `Cubit`-Instanz, zus√§tzlich zur `Change` selbst.

### Fehlerbehandlung

> Jeder `Cubit` hat eine `addError`-Methode, die verwendet werden kann, um anzuzeigen, dass ein Fehler aufgetreten ist.

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit_on_error.dart.md ':include')

?> **Hinweis**: `onError` kann innerhalb des `Cubits` √ºberschrieben werden, um alle Fehler f√ºr einen bestimmten `Cubit` zu behandeln.

Die Option `onError` kann auch in `BlocObserver` √ºberschrieben werden, um alle gemeldeten Fehler global zu behandeln.

[simple_bloc_observer.dart](../_snippets/core_concepts/simple_bloc_observer_on_error.dart.md ':include')

Wenn wir das gleiche Programm noch einmal ausf√ºhren, sollten wir die folgende Ausgabe sehen:

[script](../_snippets/core_concepts/counter_cubit_on_error_output.sh.md ':include')

?> **Hinweis**: Genau wie bei `onChange` wird die interne `onError`-√úberschreibung vor der globalen `BlocObserver`-√úberschreibung aufgerufen.

## Bloc

> Ein `Bloc` ist eine fortgeschrittenere Klasse, die sich auf Ereignisse `events` st√ºtzt, um Zustands√§nderungen `states` auszul√∂sen, anstatt auf Funktionen. `Bloc` erweitert auch `BlocBase`, was bedeutet, dass es eine √§hnliche √∂ffentliche API wie `Cubit` hat. Anstatt jedoch eine Funktion `function` auf einem `Bloc` aufzurufen und direkt einen neuen Zustand `state` auszugeben, empfangen `Blocs` Ereignisse `events` und wandeln die eingehenden Ereignisse `events` in ausgehende Zust√§nde `states` um.

![Bloc Architecture](assets/bloc_architecture_full.png)

### Einen Bloc erstellen

Die Erstellung eines `Blocs` √§hnelt der Erstellung eines `Cubits`, mit dem Unterschied, dass wir nicht nur den Zustand definieren, den wir verwalten, sondern auch das Ereignis `event`, damit der `Bloc` weiter verarbeiten kann.

> Ereignisse sind Inputs f√ºr einen Bloc. Sie werden in der Regel als Reaktion auf Benutzerinteraktionen wie das Dr√ºcken von Schaltfl√§chen oder Lebenszyklusereignisse wie das Laden von Seiten hinzugef√ºgt.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc.dart.md ':include')

Genau wie bei der Erstellung des `CounterCubits` m√ºssen wir einen Anfangszustand angeben, indem wir ihn √ºber `super` an die Superklasse √ºbergeben.

### Zustands√§nderungen

`Bloc` erfordert die Registrierung von Event-Handlern √ºber die `on<Event>` API, im Gegensatz zu Funktionen in` cubit`.Ein Ereignishandler ist daf√ºr verantwortlich, alle eingehenden Ereignisse in null oder mehr ausgehende Zust√§nde zu konvertieren.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_event_handler.dart.md ':include')

?> üí° **Tipp**: Ein `EventHandler` hat Zugriff auf das zus√§tzliche Ereignis sowie einen `Emitter` , der verwendet werden kann, um Null- oder mehr Zust√§nde als Reaktion auf das eingehende Ereignis auszusetzen.

Wir k√∂nnen dann den `Event-Handler` aktualisieren, um das `CounterIncrementPressed` Ereignis zu behandeln:

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_increment.dart.md ':include')

In the above snippet, we have registered an `EventHandler` to manage all `CounterIncrementPressed` events. For each incoming `CounterIncrementPressed` event we can access the current state of the bloc via the `state` getter and `emit(state + 1)`.

?> **Hinweis**: Da die Klasse `Bloc` die Klasse `BlocBase` erweitert, haben wir √ºber den Getter `state` zu jedem Zeitpunkt Zugriff auf den aktuellen Zustand des Blocs.

!> Blocs sollten niemals direkt neue Zust√§nde emittieren `emit`. Stattdessen muss jede Zustands√§nderung als Reaktion auf ein eingehendes Ereignis innerhalb eines `EventHandlers` ausgegeben werden.

!> Sowohl Blocs als auch Cubits ignorieren doppelte Zust√§nde. Wenn wir `State nextState` ausgeben oder emittieren, obwohl `state == nextState` bereits wahr ist, wird kein Zustandswechsel stattfinden.

### Verwendung eines Blocs

An dieser Stelle k√∂nnen wir eine Instanz unseres `CounterBlocs` erstellen und ihn verwenden!

#### Grundlegende Verwendung

[main.dart](../_snippets/core_concepts/counter_bloc_usage.dart.md ':include')

In dem obigen Ausschnitt wird zun√§chst eine Instanz des `CounterBlocs` erstellt. Dann geben wir den aktuellen Zustand des `Blocs` aus, der den Anfangszustand darstellt, da noch keine neuen Zust√§nde emittiert wurden. Als n√§chstes f√ºgen wir das Inkrement-Ereignis hinzu, um eine Zustands√§nderung auszul√∂sen. Schlie√ülich geben wir den Zustand des `Blocs` wieder aus, der den Wert von 0 auf 1 ge√§ndert hat, und schlie√üen den Block `Bloc`, um den internen Zustandsstrom zu schlie√üen.

?> **Hinweis**: Die Option `await Future.delayed(Duration.zero)` wird hinzugef√ºgt, um sicherzustellen, dass auf die n√§chste Iteration der Ereignisschleife gewartet wird(Erlaube dem `EventHandler`, um das Ereignis zu verarbeiten).

#### Stream-Nutzung

Genau wie bei `Cubit` ist ein `Bloc` ein spezieller Typ von `Stream`, was bedeutet, dass wir auch einen `Bloc` abonnieren k√∂nnen, um seinen Zustand in Echtzeit zu aktualisieren:

[main.dart](../_snippets/core_concepts/counter_bloc_stream_usage.dart.md ':include')

Im obigen Ausschnitt abonnieren wir den `CounterBloc` und rufen print bei jeder Zustands√§nderung auf. Wir f√ºgen dann das `CounterIncrementPressed` Ereignis hinzu, das auf `on<CounterIncrementPressed>` `EventHandler` l√∂st und einen neuen Zustand emittiert. Schlie√ülich rufen wir `cancel()` bei der `subscription` auf, wenn wir keine Aktualisierungen mehr erhalten wollen, und schlie√üen den `Bloc`.

?> **Hinweis**: F√ºr dieses Beispiel wurde `await Future.delayed(Duration.zero)` hinzugef√ºgt, um zu vermeiden, dass das Subscription sofort abgebrochen wird.

### Ein Bloc observieren

Da `Bloc` `BlocBase` erweitert, k√∂nnen wir alle Zustands√§nderungen f√ºr einen `Bloc` mit `onChange` beobachten.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_on_change.dart.md ':include')

Wir k√∂nnen dann `main.dart` aktualisieren zu:

[main.dart](../_snippets/core_concepts/counter_bloc_on_change_usage.dart.md ':include')

Wenn wir nun das obige Snippet ausf√ºhren, wird die Ausgabe folgendes sein:

[script](../_snippets/core_concepts/counter_bloc_on_change_output.sh.md ':include')

Ein wichtiger Unterschied zwischen `Bloc` und `Cubit` besteht darin, dass `Bloc` ereignisgesteuert (event-driven) ist und daher auch Informationen √ºber den Ausl√∂ser der Zustands√§nderung erfasst werden k√∂nnen

Wir k√∂nnen dies tun, indem wir `onTransition` √ºberschreiben.

> Der √úbergang von einem Zustand in einen anderen wird als `Transition` bezeichnet. Ein `Transition` besteht aus dem aktuellen Zustand, dem Ereignis und dem n√§chsten Zustand.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_on_transition.dart.md ':include')

Wenn wir dann denselben `main.dart`-Schnipsel wie zuvor erneut ausf√ºhren, sollten wir die folgende Ausgabe sehen:

[script](../_snippets/core_concepts/counter_bloc_on_transition_output.sh.md ':include')

?> **Note**: `onTransition` is invoked before `onChange` and contains the event which triggered the change from `currentState` to `nextState`.

#### BlocObserver

Genau wie zuvor k√∂nnen wir `onTransition` in einem benutzerdefinierten `BlocObserver` √ºberschreiben, um alle √úberg√§nge zu beobachten, die an einem einzigen Ort stattfinden.

[simple_bloc_observer.dart](../_snippets/core_concepts/simple_bloc_observer_on_transition.dart.md ':include')

Wir k√∂nnen den `SimpleBlocObserver` genau wie zuvor initialisieren:

[main.dart](../_snippets/core_concepts/simple_bloc_observer_on_transition_usage.dart.md ':include')

Wenn wir nun das obige Snippet ausf√ºhren, sollte die Ausgabe wie folgt aussehen:

[script](../_snippets/core_concepts/simple_bloc_observer_on_transition_output.sh.md ':include')

?> **Hinweis**: Die Funktion `onTransition` wird zuerst aufgerufen (lokal vor global), gefolgt von `onChange`.

Ein weiteres einzigartiges Merkmal von `Bloc`-Instanzen ist, dass sie uns erlauben, `onEvent` zu √ºberschreiben, das immer dann aufgerufen wird, wenn ein neues Ereignis zum `Bloc` hinzugef√ºgt wird. Genau wie bei `onChange` und `onTransition` kann `onEvent` sowohl lokal als auch global √ºberschrieben werden.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_on_event.dart.md ':include')

[simple_bloc_observer.dart](../_snippets/core_concepts/simple_bloc_observer_on_event.dart.md ':include')

Wir k√∂nnen dieselbe `main.dart` wie zuvor ausf√ºhren und sollten die folgende Ausgabe sehen:

[script](../_snippets/core_concepts/simple_bloc_observer_on_event_output.sh.md ':include')

?> **Hinweis**: `onEvent` wird aufgerufen, sobald das Ereignis hinzugef√ºgt wird. Das lokale `onEvent` wird vor dem globalen `onEvent` in `BlocObserver` aufgerufen.

### Fehlerbehandlung

Genau wie bei `Cubit` hat jeder `Bloc` eine `addError` und `onError` Methode. Wir k√∂nnen anzeigen, dass ein Fehler aufgetreten ist, indem wir `addError` von √ºberall innerhalb unseres `Bloc` aufrufen. Wir k√∂nnen dann auf alle Fehler reagieren, indem wir `onError` genau wie bei `Cubit` √ºberschreiben.

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_on_error.dart.md ':include')

Wenn wir dieselbe `main.dart` wie zuvor erneut ausf√ºhren, k√∂nnen wir sehen, wie es aussieht, wenn ein Fehler gemeldet wird:

[script](../_snippets/core_concepts/counter_bloc_on_error_output.sh.md ':include')

?> **Hinweis**: Das lokale `onError` wird zuerst aufgerufen, gefolgt von dem globalen `onError` in `BlocObserver`.

?> **Hinweis**: `onError` und `onChange` funktionieren f√ºr `Bloc` und `Cubit` Instanzen genau gleich.

!> Alle unbehandelten Ausnahmen, die innerhalb von `EventHandler` auftreten, werden auch an `onError` gemeldet.

## Cubit vs. Bloc

Nachdem wir nun die Grundlagen der Klassen `Cubit` und `Bloc` behandelt haben, fragen Sie sich vielleicht, wann Sie `Cubit` und wann Sie `Bloc` verwenden sollten.

### Vorteile von Cubit

#### Einfachheit

Einer der gr√∂√üten Vorteile bei der Verwendung von `Cubit` ist die Einfachheit. Bei der Erstellung eines `Cubits` m√ºssen wir nur den Zustand sowie die Funktionen definieren, die wir zur √Ñnderung des Zustands bereitstellen wollen. Im Vergleich dazu m√ºssen wir bei der Erstellung eines `Blocs` die Zust√§nde, Ereignisse und die Implementierung von `EventHandler` definieren. Das macht `Cubit` leicht verst√§ndlich und es ist weniger Code erforderlich.

Werfen wir nun einen Blick auf die beiden Z√§hlerimplementierungen:

##### CounterCubit

[counter_cubit.dart](../_snippets/core_concepts/counter_cubit_full.dart.md ':include')

##### CounterBloc

[counter_bloc.dart](../_snippets/core_concepts/counter_bloc_full.dart.md ':include')

Die Implementierung von `Cubit` ist pr√§ziser und anstatt Ereignisse separat zu definieren, fungieren die Funktionen wie Ereignisse. Bei Verwendung eines `Cubit`, k√∂nnen wir einfach `emit` von √ºberall anrufen, um eine Zustands√§nderung auszul√∂sen.

### Vorteile von Bloc

#### R√ºckverfolgbarkeit

Einer der gr√∂√üten Vorteile bei der Verwendung von `Bloc` ist die Kenntnis der Abfolge von Zustands√§nderungen sowie der genauen Ausl√∂ser dieser √Ñnderungen. Bei Zust√§nden, die f√ºr die Funktionalit√§t einer Anwendung von entscheidender Bedeutung sind, kann es sehr vorteilhaft sein, einen st√§rker ereignisorientierten Ansatz zu verwenden, um alle Ereignisse zus√§tzlich zu den Zustands√§nderungen zu erfassen.

Ein h√§ufiger Anwendungsfall k√∂nnte die Verwaltung von `AuthenticationState` sein. Der Einfachheit halber nehmen wir an, dass wir `AuthenticationState` durch ein `enum` darstellen k√∂nnen:

[authentication_state.dart](../_snippets/core_concepts/authentication_state.dart.md ':include')

Es kann viele Gr√ºnde geben, warum der Status der Anwendung von authentifiziert `authenticated` zu nicht authentifiziert `unauthenticated` wechselt. Zum Beispiel k√∂nnte der Benutzer auf eine Abmeldeschaltfl√§che getippt haben, um eine Abmeldung von der Anwendung durchzuf√ºhren. Andererseits kann es auch sein, dass dem Benutzer das Zugriffstoken (access token) entzogen wurde und er zwangsweise abgemeldet wurde. Wenn wir`Bloc` verwenden, k√∂nnen wir eindeutig nachvollziehen, wie der Zustand der Anwendung zu einem bestimmten Zustand passiert ist.

[script](../_snippets/core_concepts/authentication_transition.sh.md ':include')

Die obige `Transition` gibt uns alle Informationen, die wir brauchen, um zu verstehen, warum sich der Zustand ge√§ndert hat. H√§tten wir ein `Cubit` zur Verwaltung des `AuthenticationState` verwendet, w√ºrden unsere Logs wie folgt aussehen:

[script](../_snippets/core_concepts/authentication_change.sh.md ':include')

Dies sagt uns, dass der Benutzer abgemeldet wurde, aber es erkl√§rt nicht die Ursache, was f√ºr die Fehlersuche und das Verst√§ndnis, wie sich der Zustand der Anwendung im Laufe der Zeit ver√§ndert hat, entscheidend sein k√∂nnte.

#### AdvanErweiterteced Ereignistransformationen

Ein weiterer Bereich, in dem sich `Bloc` gegen√ºber `Cubit` auszeichnet, ist, wenn wir die Vorteile reaktiver Operatoren wie `buffer`, `debounceTime`, `throttle`, usw. nutzen m√ºssen.

`Bloc` hat eine Ereignissenke (event sink), die es uns erlaubt, den eingehenden Fluss von Ereignissen zu kontrollieren und zu transformieren.

Wenn wir zum Beispiel eine Echtzeit-Suche aufbauen w√ºrden, w√ºrden wir wahrscheinlich die Anfragen an das Backend entschleunigen wollen, um eine Ratenbeschr√§nkung zu vermeiden und um die Kosten/Last auf dem Backend zu reduzieren.

Mit `Bloc` k√∂nnen wir `EventTransformer` √ºberschreiben, um die Art und Weise zu √§ndern, wie eingehende Ereignisse von `Bloc` verarbeitet werden.

[counter_bloc.dart](../_snippets/core_concepts/debounce_event_transformer.dart.md ':include')

Mit dem obigen Code k√∂nnen wir die eingehenden Ereignisse mit sehr wenig zus√§tzlichem Code leicht entschleunigen.

?> üí° **Tipp**: Kasse [package:bloc_concurrency](https://pub.dev/packages/bloc_concurrency) F√ºr einen anhaltenden Satz von `EventTransformers`.

?> üí° **Tipp**: Wenn Sie noch unsicher sind, was Sie verwenden sollen, beginnen Sie mit `Cubit` und Sie k√∂nnen sp√§ter je nach Bedarf auf `Bloc` umstellen oder skalieren.
