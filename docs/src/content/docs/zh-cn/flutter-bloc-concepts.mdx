---
title: Flutter Bloc 概念
description: package:flutter_bloc 的核心概念概览
sidebar:
  order: 2
---

import BlocBuilderSnippet from '~/components/concepts/flutter-bloc/BlocBuilderSnippet.astro';
import BlocBuilderExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocBuilderExplicitBlocSnippet.astro';
import BlocBuilderConditionSnippet from '~/components/concepts/flutter-bloc/BlocBuilderConditionSnippet.astro';
import BlocSelectorSnippet from '~/components/concepts/flutter-bloc/BlocSelectorSnippet.astro';
import BlocProviderSnippet from '~/components/concepts/flutter-bloc/BlocProviderSnippet.astro';
import BlocProviderEagerSnippet from '~/components/concepts/flutter-bloc/BlocProviderEagerSnippet.astro';
import BlocProviderValueSnippet from '~/components/concepts/flutter-bloc/BlocProviderValueSnippet.astro';
import BlocProviderLookupSnippet from '~/components/concepts/flutter-bloc/BlocProviderLookupSnippet.astro';
import NestedBlocProviderSnippet from '~/components/concepts/flutter-bloc/NestedBlocProviderSnippet.astro';
import MultiBlocProviderSnippet from '~/components/concepts/flutter-bloc/MultiBlocProviderSnippet.astro';
import BlocListenerSnippet from '~/components/concepts/flutter-bloc/BlocListenerSnippet.astro';
import BlocListenerExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocListenerExplicitBlocSnippet.astro';
import BlocListenerConditionSnippet from '~/components/concepts/flutter-bloc/BlocListenerConditionSnippet.astro';
import NestedBlocListenerSnippet from '~/components/concepts/flutter-bloc/NestedBlocListenerSnippet.astro';
import MultiBlocListenerSnippet from '~/components/concepts/flutter-bloc/MultiBlocListenerSnippet.astro';
import BlocConsumerSnippet from '~/components/concepts/flutter-bloc/BlocConsumerSnippet.astro';
import BlocConsumerConditionSnippet from '~/components/concepts/flutter-bloc/BlocConsumerConditionSnippet.astro';
import RepositoryProviderSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderSnippet.astro';
import RepositoryProviderLookupSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderLookupSnippet.astro';
import NestedRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/NestedRepositoryProviderSnippet.astro';
import MultiRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/MultiRepositoryProviderSnippet.astro';
import CounterBlocSnippet from '~/components/concepts/flutter-bloc/CounterBlocSnippet.astro';
import CounterMainSnippet from '~/components/concepts/flutter-bloc/CounterMainSnippet.astro';
import CounterPageSnippet from '~/components/concepts/flutter-bloc/CounterPageSnippet.astro';
import WeatherRepositorySnippet from '~/components/concepts/flutter-bloc/WeatherRepositorySnippet.astro';
import WeatherMainSnippet from '~/components/concepts/flutter-bloc/WeatherMainSnippet.astro';
import WeatherAppSnippet from '~/components/concepts/flutter-bloc/WeatherAppSnippet.astro';
import WeatherPageSnippet from '~/components/concepts/flutter-bloc/WeatherPageSnippet.astro';

:::note
在開始[`package:flutter_bloc`](https://pub.dev/packages/flutter_bloc) 請詳細閱讀以下文檔
:::

:::note
所有 `flutter_bloc` 套件导出的Widget都与 Cubit 和 Bloc 实例集成。
:::

## Bloc Widgets

### BlocBuilder

**BlocBuilder** 是一个 Flutter 的 Widget，它需要一个 `Bloc` 和一个 `builder` 函数。`BlocBuilder` 处理於構建响应新状态时构建的 Widget 。`BlocBuilder` 与 `StreamBuilder` 非常相似，但是 `StreamBuilder`具有更简单的 API，以减少所需的样板代码量。`builder` 函数可能会被多次调用，並且必須是一个根据状态返回一个widget的[纯函数](https://en.wikipedia.org/wiki/Pure_function)。



 如果你希望在状态变化时执行一些操作，比如导航、显示对话框等...，请查看  `BlocListener`



在BlocBuilder中，如果省略了 `bloc` 參數，則 `BlocBuilder` 會自動通過 `BlocProvider` 和當前的 `BuildContext` 進行查找

<BlocBuilderSnippet />

只有在希望提供一個僅作用於單個 widget 且無法透過父級 `BlocProvider` 和當前的 `BuildContext` 訪問的 `bloc` 時，才需要明確指定 `bloc`。

<BlocBuilderExplicitBlocSnippet />

在使用 BlocBuilder 時，如果要達到更細緻地控制 widget 的更新，可以使用 `buildWhen` 參數來實現何時調用 `builder` 函數。`buildWhen`  接受前一個 bloc 狀態和當前 bloc 狀態，並返回一個布爾值。如果 `buildWhen` 返回 true，則 `builder` 函數將被調用並使用當前 `state` 進行widget重建。如果 buildWhen 返回 false，則 `builder` 將不會被使用當前 `state` 調用，且不會進行重建。

<BlocBuilderConditionSnippet />

### BlocSelector

**BlocSelector** is a Flutter widget which is analogous to `BlocBuilder` but allows developers to filter updates by selecting a new value based on the current bloc state. Unnecessary builds are prevented if the selected value does not change. The selected value must be immutable in order for `BlocSelector` to accurately determine whether `builder` should be called again.

If the `bloc` parameter is omitted, `BlocSelector` will automatically perform a lookup using `BlocProvider` and the current `BuildContext`.

<BlocSelectorSnippet />

### BlocProvider

**BlocProvider** 是一個 Flutter widget ，透過 `BlocProvider.of<T>(context)` 將一個 bloc 提供給它的children。`BlocProvider` 用作於依賴注入（DI）widget ，以便在子樹 (subtree) 中可以提供單個 bloc 實例給多個widget 使用。

通常情況下，應該使用 `BlocProvider` 來創建新的 bloc，這樣可以使該 bloc 對於子樹中的其他 widget 使用。在這種情況下，由於 `BlocProvider` 負責創建 bloc，它將自動處理關閉該 bloc。

<BlocProviderSnippet />

默認情況下，`BlocProvider` 將延遲創建 bloc 實例，這意味著當通過 `BlocProvider.of<BlocA>(context)` 查找該 bloc 時，`create` 方法才會被執行。

為了覆蓋這種行為並強制立即運行 `create` 方法，可以將 `lazy` 設置為 `false`。

<BlocProviderEagerSnippet />

在某些情況下，可以使用 `BlocProvider` 來將一個已存在的 Bloc 提供給 Widget 樹中的新部分。這通常發生在需要將一個已存在的 Bloc 提供給新的路由（route）時。在這種情況下，`BlocProvider` 不會自動關閉 Bloc，因為它並非 Bloc 的創建者。

<BlocProviderValueSnippet />

如此，從 `ChildA` 或者 `ScreenA` 中，我們可以獲取 `BlocA`

<BlocProviderLookupSnippet />

### MultiBlocProvider

**MultiBlocProvider** 是一個 Flutter Widget 用來將多個 `BlocProvider` Widgets 合併為一個。

`MultiBlocProvider` 可以提高代碼的可讀性，消除了需要嵌套多個 `BlocProvider` 的情況。

通過使用了 `MultiBlocProvider`  我們可以從

<NestedBlocProviderSnippet />

變為

<MultiBlocProviderSnippet />

### BlocListener

**BlocListener** 是一個 Flutter Widget，它接受一個 `BlocWidgetListener` 和一個可選的 `Bloc`，並在 bloc 狀態發生變化時調用 `listener`。它應該用於需要每個狀態變化僅執行一次的功能，例如導航、顯示 `SnackBar`、顯示 `Dialog` 等等。

與 `BlocBuilder` 中的 `builder` 不同的是，`listener` 對於每個狀態變化（初始狀態除外）只會被調用一次，並且是一個 `void` 函數。

如果`bloc` 被省略沒有傳入， `BlocListener`  將自動使用 `BlocProvider` 和當前的 `BuildContext` 執行查找。

<BlocListenerSnippet />

只有在希望提供一個通過 `BlocProvider` 和當前 `BuildContext` 否則無法訪問的 bloc 的情況時，才指定 bloc。

<BlocListenerExplicitBlocSnippet />

要對 `listener` 函數何時調用進行更細緻地控制，可以提供一個可選的 `listenWhen`。`listenWhen` 接受先前的 bloc 狀態和當前的 bloc 狀態，並返回一個布爾值。如果 `listenWhen` 返回 true，則會用 `state` 調用 `listener`。如果 `listenWhen` 返回 false，則不會用 `state` 調用 `listener`。

<BlocListenerConditionSnippet />

### MultiBlocListener

**MultiBlocListener** 是 Flutter 中的一個 Widget，用來將多個 `BlocListener` Widgets 合併為一個。`MultiBlocListener` 可以提高代碼的可讀性，消除了需要嵌套多個 BlocListener 的情況。

通過使用 `MultiBlocListener`，我們可以從以下代碼轉變為：

<NestedBlocListenerSnippet />

變為

<MultiBlocListenerSnippet />

### BlocConsumer

**BlocConsumer** 提供了 `builder` 和 `listener`，以便對新的狀態做出反應。`BlocConsumer` 類似於嵌套的 `BlocListener` 和 `BlocBuilder`，但可以減少所需的樣板代碼量。只有在需要重建 UI 並執行其他對 `bloc` 狀態變化做出反應時，才應該使用 `BlocConsumer`。`BlocConsumer` 接受`BlocWidgetBuilder` (必傳參數) 和 `BlocWidgetListener` (必傳參數) ，以及 `bloc` (可選參數)、`BlocBuilderCondition`  (可選參數) 和 `BlocListenerCondition` (可選參數)。

如果`bloc` 被省略沒有傳入， `BlocConsumer`  將自動使用 `BlocProvider` 和當前的 `BuildContext` 進行查找。

<BlocConsumerSnippet />

可選參數 `listenWhen` 和 `buildWhen` 可以用來更精细地控制 `listener` 和 `builder` 何时被调用。`listenWhen` 和 `buildWhen` 将在每个 `bloc` 的 `state` 更改时被调用。它们都接受先前的 `state` 和当前的 `state`，且必须返回一个布尔值，用于确定是否调用 `builder` 和/或  `listener` 函数。当 `BlocConsumer` 初始化时，先前的 `state` 将初始化为 `bloc` 的 `state`。由於 `listenWhen` 和 `buildWhen` 是可选的，因此不实现它们時，默认为 `true`。

<BlocConsumerConditionSnippet />

### RepositoryProvider

**MultiBlocListener** 是 Flutter 中的一個 Widget，透過 `RepositoryProvider.of<T>(context)` 将 repository 提供给其子节点。它被用作依赖注入（DI）小部件，以便在子树中提供一个仓库的单个实例给多个 Widgets。`BlocProvider` 应该用于提供 bloc，而 `RepositoryProvider` 应该只用于提供 repositories。

<RepositoryProviderSnippet />

那么从 `ChildA`，我们可以通过以下代码获取 `Repository` 实例：

<RepositoryProviderLookupSnippet />

### MultiRepositoryProvider

**MultiRepositoryProvider** 是一個 Flutter Widget 用來將多個 `RepositoryProvider` Widgets 合併為一個。

`MultiRepositoryProvider` 可以提高代碼的可讀性，消除了需要嵌套多個 `RepositoryProvider` 的情況。

通過使用了 `MultiRepositoryProvider`  我們可以從

<NestedRepositoryProviderSnippet />

變為

<MultiRepositoryProviderSnippet />

## BlocProvider Usage

接著來看看如何使用  `BlocProvider`  來提供一個  `CounterBloc` 給一個 `CounterPage` 並且使用`BlocBuilder`  來對状态变化做出反应.

<CounterBlocSnippet />

<CounterMainSnippet />

<CounterPageSnippet />

到目前为止，我们成功地将我们的表示层 ( presentational layer ) 与我们的业务逻辑层 (business logic layer) 分开了。注意，`CounterPage` widget 不知道当用户点击按钮时会发生什么。该 widget 只是告诉 `CounterBloc` 用户按下了增加或减少按钮。

## RepositoryProvider Usage

接下來，我們將利用 flutter_weather 範例，來查看如何使用 RepositoryProvider。

<WeatherRepositorySnippet />

由於應用程式明確依賴於 `WeatherRepository`，我們通過建構函式注入一個實例。這使我們能夠根據構建版本或環境注入不同的 `WeatherRepository` 實例。

<WeatherMainSnippet />

由於在這個例子中，我們的應用程序只有一個  repository，我們將通過 `RepositoryProvider.value` 將其注入到我們的 widget tree 中。如果您有多個 repository，則可以使用 `MultiRepositoryProvider` 將多個 repository 實例提供給 subtree。

<WeatherAppSnippet />

在大多數情況下，应用程序的顶层 widgets 將透過 `RepositoryProvider` 向 subtree 公開一個或多個repository。

<WeatherPageSnippet />

在，在实例化一个 bloc 时，我们可以通过 `context.read` 访问存储库的实例，并通过构造函数将存储库注入到 bloc 中。

[flutter_weather_link]: https://github.com/felangel/bloc/blob/master/examples/flutter_weather

## Extension Methods

[
Extension methods](https://dart.dev/guides/language/extension-methods)，在 Dart 2.7 中引入，是一种向现有库添加功能的方法。在本节中，我们将看一下 `package:flutter_bloc` 中包含的扩展方法以及它们的使用方式。

`flutter_bloc` 依赖于 [package:provider](https://pub.dev/packages/provider)，它简化了对 [`InheritedWidget`](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html) 的使用。

在内部，`package:flutter_bloc` 使用 `package:provider` 实现了 `BlocProvider`、`MultiBlocProvider`、`RepositoryProvider` 和 `MultiRepositoryProvider` widgets。 `package:flutter_bloc` 从 `package:provider` 中导出了 `ReadContext`、`WatchContext` 和 `SelectContext` 扩展。



:::note
查詢更多關於  [`package:provider`](https://pub.dev/packages/provider).
:::

### context.read

`context.read<T>()` 查找最接近的类型为 T 的祖先实例，并在功能上等同于 `BlocProvider.of<T>(context)`。`context.read` 最常用于在 `onPressed` 回调中检索 bloc 实例以添加事件。

`context.read<T>()` looks up the closest ancestor instance of type `T` and is functionally equivalent to `BlocProvider.of<T>(context)`. `context.read` is most commonly used for retrieving a bloc instance in order to add an event within `onPressed` callbacks.

:::note

`context.read<T>()` 不会监听 `T` —— 如果提供的类型为 `T` 的对象发生变化，`context.read` 不会触发 widget重建。

:::

#### Usage

✅ **DO** use `context.read` to add events in callbacks.

```dart
onPressed() {
  context.read<CounterBloc>().add(CounterIncrementPressed()),
}
```

❌ **AVOID** using `context.read` to retrieve state within a `build` method.

```dart
@override
Widget build(BuildContext context) {
  final state = context.read<MyBloc>().state;
  return Text('$state');
}
```

The above usage is error prone because the `Text` widget will not be rebuilt if the state of the bloc changes.

:::caution
Use `BlocBuilder` or `context.watch` instead in order to rebuild in response to state changes.
:::

### context.watch

Like `context.read<T>()`, `context.watch<T>()` provides the closest ancestor instance of type `T`, however it also listens to changes on the instance. It is functionally equivalent to `BlocProvider.of<T>(context, listen: true)`.

If the provided `Object` of type `T` changes, `context.watch` will trigger a rebuild.

:::caution
`context.watch` is only accessible within the `build` method of a `StatelessWidget` or `State` class.
:::

#### Usage

✅ **DO** use `BlocBuilder` instead of `context.watch` to explicitly scope rebuilds.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocBuilder<MyBloc, MyState>(
        builder: (context, state) {
          // Whenever the state changes, only the Text is rebuilt.
          return Text(state.value);
        },
      ),
    ),
  );
}
```

Alternatively, use a `Builder` to scope rebuilds.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Whenever the state changes, only the Text is rebuilt.
          final state = context.watch<MyBloc>().state;
          return Text(state.value);
        },
      ),
    ),
  );
}
```

✅ **DO** use `Builder` and `context.watch` as `MultiBlocBuilder`.

```dart
Builder(
  builder: (context) {
    final stateA = context.watch<BlocA>().state;
    final stateB = context.watch<BlocB>().state;
    final stateC = context.watch<BlocC>().state;

    // return a Widget which depends on the state of BlocA, BlocB, and BlocC
  }
);
```

❌ **AVOID** using `context.watch` when the parent widget in the `build` method doesn't depend on the state.

```dart
@override
Widget build(BuildContext context) {
  // Whenever the state changes, the MaterialApp is rebuilt
  // even though it is only used in the Text widget.
  final state = context.watch<MyBloc>().state;
  return MaterialApp(
    home: Scaffold(
      body: Text(state.value),
    ),
  );
}
```

:::caution
Using `context.watch` at the root of the `build` method will result in the entire widget being rebuilt when the bloc state changes.
:::

### context.select

Just like `context.watch<T>()`, `context.select<T, R>(R function(T value))` provides the closest ancestor instance of type `T` and listens to changes on `T`. Unlike `context.watch`, `context.select` allows you listen for changes in a smaller part of a state.

```dart
Widget build(BuildContext context) {
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return Text(name);
}
```

The above will only rebuild the widget when the property `name` of the `ProfileBloc`'s state changes.

#### Usage

✅ **DO** use `BlocSelector` instead of `context.select` to explicitly scope rebuilds.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocSelector<ProfileBloc, ProfileState, String>(
        selector: (state) => state.name,
        builder: (context, name) {
          // Whenever the state.name changes, only the Text is rebuilt.
          return Text(name);
        },
      ),
    ),
  );
}
```

Alternatively, use a `Builder` to scope rebuilds.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Whenever state.name changes, only the Text is rebuilt.
          final name = context.select((ProfileBloc bloc) => bloc.state.name);
          return Text(name);
        },
      ),
    ),
  );
}
```

❌ **AVOID** using `context.select` when the parent widget in a build method doesn't depend on the state.

```dart
@override
Widget build(BuildContext context) {
  // Whenever the state.value changes, the MaterialApp is rebuilt
  // even though it is only used in the Text widget.
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return MaterialApp(
    home: Scaffold(
      body: Text(name),
    ),
  );
}
```

:::caution
Using `context.select` at the root of the `build` method will result in the entire widget being rebuilt when the selection changes.
:::
