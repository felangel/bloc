---
title: Preguntas Frecuentes
description: Respuestas a preguntas frecuentes sobre la biblioteca bloc.
---

import StateNotUpdatingGood1Snippet from '~/components/faqs/StateNotUpdatingGood1Snippet.astro';
import StateNotUpdatingGood2Snippet from '~/components/faqs/StateNotUpdatingGood2Snippet.astro';
import StateNotUpdatingGood3Snippet from '~/components/faqs/StateNotUpdatingGood3Snippet.astro';
import StateNotUpdatingBad1Snippet from '~/components/faqs/StateNotUpdatingBad1Snippet.astro';
import StateNotUpdatingBad2Snippet from '~/components/faqs/StateNotUpdatingBad2Snippet.astro';
import StateNotUpdatingBad3Snippet from '~/components/faqs/StateNotUpdatingBad3Snippet.astro';
import EquatableEmitSnippet from '~/components/faqs/EquatableEmitSnippet.astro';
import EquatableBlocTestSnippet from '~/components/faqs/EquatableBlocTestSnippet.astro';
import NoEquatableBlocTestSnippet from '~/components/faqs/NoEquatableBlocTestSnippet.astro';
import SingleStateSnippet from '~/components/faqs/SingleStateSnippet.astro';
import SingleStateUsageSnippet from '~/components/faqs/SingleStateUsageSnippet.astro';
import BlocProviderGood1Snippet from '~/components/faqs/BlocProviderGood1Snippet.astro';
import BlocProviderGood2Snippet from '~/components/faqs/BlocProviderGood2Snippet.astro';
import BlocProviderBad1Snippet from '~/components/faqs/BlocProviderBad1Snippet.astro';
import BlocInternalAddEventSnippet from '~/components/faqs/BlocInternalAddEventSnippet.astro';
import BlocInternalEventSnippet from '~/components/faqs/BlocInternalEventSnippet.astro';
import BlocExternalForEachSnippet from '~/components/faqs/BlocExternalForEachSnippet.astro';

## Estado No Actualizado

‚ùî **Pregunta**: Estoy emitiendo un estado en mi bloc pero la interfaz de usuario no se actualiza. ¬øQu√© estoy haciendo mal?

üí° **Respuesta**: Si est√°s usando Equatable, aseg√∫rate de pasar todas las propiedades al getter props.

‚úÖ **BUENO**

<StateNotUpdatingGood1Snippet />

‚ùå **MALO**

<StateNotUpdatingBad1Snippet />

<StateNotUpdatingBad2Snippet />

Adem√°s, aseg√∫rate de emitir una nueva instancia del estado en tu bloc.

‚úÖ **BUENO**

<StateNotUpdatingGood2Snippet />

<StateNotUpdatingGood3Snippet />

‚ùå **MALO**

<StateNotUpdatingBad3Snippet />

:::caution
Las propiedades de `Equatable` siempre deben ser copiadas en lugar de modificadas. Si una clase `Equatable` contiene una `Lista` o `Mapa` como propiedades, aseg√∫rate de usar `List.of` o `Map.of` respectivamente para garantizar que la igualdad se eval√∫e en funci√≥n de los valores de las propiedades en lugar de la referencia.
:::

## Cu√°ndo usar Equatable

‚ùî**Pregunta**: ¬øCu√°ndo debo usar Equatable?

üí°**Respuesta**:

<EquatableEmitSnippet />

En el escenario anterior, si `StateA` extiende `Equatable`, solo ocurrir√° un cambio de estado (el segundo emit ser√° ignorado). En general, debes usar `Equatable` si deseas optimizar tu c√≥digo para reducir el n√∫mero de reconstrucciones. No debes usar `Equatable` si deseas que el mismo estado consecutivo desencadene m√∫ltiples transiciones.

Adem√°s, usar `Equatable` facilita mucho las pruebas de blocs, ya que podemos esperar instancias espec√≠ficas de estados de bloc en lugar de usar `Matchers` o `Predicates`.

<EquatableBlocTestSnippet />

Sin `Equatable`, la prueba anterior fallar√≠a y necesitar√≠a ser reescrita as√≠:

<NoEquatableBlocTestSnippet />

## Manejo de Errores

‚ùî **Pregunta**: ¬øC√≥mo puedo manejar un error mientras sigo mostrando datos anteriores?

üí° **Respuesta**:

Esto depende en gran medida de c√≥mo se haya modelado el estado del bloc. En casos donde los datos deben mantenerse incluso en presencia de un error, considera usar una sola clase de estado.

<SingleStateSnippet />

Esto permitir√° que los widgets tengan acceso a las propiedades `data` y `error` simult√°neamente y el bloc puede usar `state.copyWith` para mantener los datos antiguos incluso cuando ocurra un error.

<SingleStateUsageSnippet />

## Bloc vs. Redux

‚ùî **Pregunta**: ¬øCu√°l es la diferencia entre Bloc y Redux?

üí° **Respuesta**:

BLoC es un patr√≥n de dise√±o que se define por las siguientes reglas:

1. La entrada y salida del BLoC son Streams y Sinks simples.
2. Las dependencias deben ser inyectables y agn√≥sticas de la plataforma.
3. No se permite la bifurcaci√≥n de la plataforma.
4. La implementaci√≥n puede ser lo que quieras siempre que sigas las reglas anteriores.

Las pautas de la interfaz de usuario son:

1. Cada componente "lo suficientemente complejo" tiene un BLoC correspondiente.
2. Los componentes deben enviar entradas "tal como est√°n".
3. Los componentes deben mostrar salidas lo m√°s cerca posible de "tal como est√°n".
4. Toda la bifurcaci√≥n debe basarse en salidas booleanas simples del BLoC.

La biblioteca Bloc implementa el patr√≥n de dise√±o BLoC y tiene como objetivo abstraer RxDart para simplificar la experiencia del desarrollador.

Los tres principios de Redux son:

1. Fuente √∫nica de verdad
2. El estado es de solo lectura
3. Los cambios se realizan con funciones puras

La biblioteca bloc viola el primer principio; con bloc, el estado se distribuye a trav√©s de m√∫ltiples blocs. Adem√°s, no hay concepto de middleware en bloc y bloc est√° dise√±ado para facilitar los cambios de estado asincr√≥nicos, permiti√©ndote emitir m√∫ltiples estados para un solo evento.

## Bloc vs. Provider

‚ùî **Pregunta**: ¬øCu√°l es la diferencia entre Bloc y Provider?

üí° **Respuesta**: `provider` est√° dise√±ado para la inyecci√≥n de dependencias (envuelve
`InheritedWidget`). A√∫n necesitas averiguar c√≥mo gestionar tu estado (a trav√©s de
`ChangeNotifier`, `Bloc`, `Mobx`, etc...). La biblioteca Bloc usa `provider`
internamente para facilitar la provisi√≥n y acceso a blocs a lo largo del √°rbol de widgets.

## BlocProvider.of() No Encuentra el Bloc

‚ùî **Pregunta**: Cuando uso `BlocProvider.of(context)` no puede encontrar el bloc.
¬øC√≥mo puedo solucionar esto?

üí° **Respuesta**: No puedes acceder a un bloc desde el mismo contexto en el que fue
proporcionado, por lo que debes asegurarte de que `BlocProvider.of()` se llame dentro de un
`BuildContext` hijo.

‚úÖ **BUENO**

<BlocProviderGood1Snippet />

<BlocProviderGood2Snippet />

‚ùå **MALO**

<BlocProviderBad1Snippet />

## Estructura del Proyecto

‚ùî **Pregunta**: ¬øC√≥mo debo estructurar mi proyecto?

üí° **Respuesta**: Aunque realmente no hay una respuesta correcta/incorrecta a esta pregunta, algunas
referencias recomendadas son:

- [I/O Photobooth](https://github.com/flutter/photobooth)
- [I/O Pinball](https://github.com/flutter/pinball)
- [Flutter News Toolkit](https://github.com/flutter/news_toolkit)

Lo m√°s importante es tener una estructura de proyecto **consistente** e **intencional**.

## Agregar Eventos dentro de un Bloc

‚ùî **Pregunta**: ¬øEst√° bien agregar eventos dentro de un bloc?

üí° **Respuesta**: En la mayor√≠a de los casos, los eventos deben agregarse externamente, pero en algunos
casos selectos puede tener sentido que los eventos se agreguen internamente.

La situaci√≥n m√°s com√∫n en la que se utilizan eventos internos es cuando los cambios de estado
deben ocurrir en respuesta a actualizaciones en tiempo real desde un repositorio. En estas
situaciones, el repositorio es el est√≠mulo para el cambio de estado en lugar de un evento
externo como un toque de bot√≥n.

En el siguiente ejemplo, el estado de `MyBloc` depende del usuario actual
que se expone a trav√©s del `Stream<User>` del `UserRepository`. `MyBloc`
escucha los cambios en el usuario actual y agrega un evento interno `_UserChanged`
cada vez que se emite un usuario desde el flujo de usuarios.

<BlocInternalAddEventSnippet />

Al agregar un evento interno, tambi√©n podemos especificar un `transformer` personalizado
para el evento para determinar c√≥mo se procesar√°n m√∫ltiples eventos `_UserChanged` -- por defecto se procesar√°n concurrentemente.

Se recomienda encarecidamente que los eventos internos sean privados. Esta es una forma expl√≠cita
de se√±alar que un evento espec√≠fico se usa solo dentro del bloc y evita que los componentes externos
conozcan el evento.

<BlocInternalEventSnippet />

Alternativamente, podemos definir un evento externo `Started` y usar la API
`emit.forEach` para manejar la reacci√≥n a las actualizaciones de usuarios en tiempo real:

<BlocExternalForEachSnippet />

Los beneficios del enfoque anterior son:

- No necesitamos un evento interno `_UserChanged`
- No necesitamos gestionar manualmente la `StreamSubscription`
- Tenemos control total sobre cu√°ndo el bloc se suscribe al flujo de actualizaciones de usuarios

Las desventajas del enfoque anterior son:

- No podemos `pausar` o `reanudar` f√°cilmente la suscripci√≥n
- Necesitamos exponer un evento p√∫blico `Started` que debe agregarse externamente
- No podemos usar un `transformer` personalizado para ajustar c√≥mo reaccionamos a las actualizaciones de usuarios

## Exponer M√©todos P√∫blicos

‚ùî **Pregunta**: ¬øEst√° bien exponer m√©todos p√∫blicos en mis instancias de bloc y cubit?

üí° **Respuesta**

Al crear un cubit, se recomienda exponer solo m√©todos p√∫blicos con el prop√≥sito de desencadenar cambios de estado. Como resultado, generalmente todos los m√©todos p√∫blicos en una instancia de cubit deben devolver `void` o `Future<void>`.

Al crear un bloc, se recomienda evitar exponer cualquier m√©todo p√∫blico personalizado y en su lugar notificar al bloc de eventos llamando a `add`.
