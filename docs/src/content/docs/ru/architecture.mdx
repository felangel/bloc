---
title: Архитектура
description: Обзор рекомендуемых архитектурных шаблонов при использовании bloc.
---

import DataProviderSnippet from '~/components/architecture/DataProviderSnippet.astro';
import RepositorySnippet from '~/components/architecture/RepositorySnippet.astro';
import BusinessLogicComponentSnippet from '~/components/architecture/BusinessLogicComponentSnippet.astro';
import BlocTightCouplingSnippet from '~/components/architecture/BlocTightCouplingSnippet.astro';
import BlocLooseCouplingPresentationSnippet from '~/components/architecture/BlocLooseCouplingPresentationSnippet.astro';
import AppIdeasRepositorySnippet from '~/components/architecture/AppIdeasRepositorySnippet.astro';
import AppIdeaRankingBlocSnippet from '~/components/architecture/AppIdeaRankingBlocSnippet.astro';
import PresentationComponentSnippet from '~/components/architecture/PresentationComponentSnippet.astro';

![Архитектура Bloc](~/assets/concepts/bloc_architecture_full.png)

Использование библиотеки bloc позволяет нам разделить наше приложение на три
слоя:

- Представление
- Бизнес-логика
- Данные
  - Репозиторий
  - Поставщик данных

Мы начнем с самого нижнего слоя (наиболее удаленного от пользовательского
интерфейса) и будем двигаться вверх к слою представления.

## Слой данных

Ответственность слоя данных заключается в получении/манипулировании данными из
одного или нескольких источников.

Слой данных можно разделить на две части:

- Репозиторий
- Поставщик данных

Этот слой является самым низким уровнем приложения и взаимодействует с базами
данных, сетевыми запросами и другими асинхронными источниками данных.

### Поставщик данных

Ответственность поставщика данных заключается в предоставлении необработанных
данных. Поставщик данных должен быть универсальным и многофункциональным.

Поставщик данных обычно предоставляет простые API для выполнения
[CRUD](https://ru.wikipedia.org/wiki/CRUD) операций. У нас могут быть методы
`createData`, `readData`, `updateData` и `deleteData` как часть нашего слоя
данных.

<DataProviderSnippet />

### Репозиторий

Слой репозитория — это обертка вокруг одного или нескольких поставщиков данных,
с которыми общается слой Bloc.

<RepositorySnippet />

Как вы можете видеть, наш слой репозитория может взаимодействовать с несколькими
поставщиками данных и выполнять преобразования данных перед передачей результата
на слой бизнес-логики.

## Слой бизнес-логики

Ответственность слоя бизнес-логики заключается в ответе на ввод из слоя
представления новыми состояниями. Этот слой может зависеть от одного или
нескольких репозиториев для получения данных, необходимых для построения
состояния приложения.

Думайте о слое бизнес-логики как о мосте между пользовательским интерфейсом
(слой представления) и слоем данных. Слой бизнес-логики уведомляется о
событиях/действиях из слоя представления, а затем взаимодействует с
репозиторием, чтобы построить новое состояние для использования слоем
представления.

<BusinessLogicComponentSnippet />

### Взаимодействие между блоками

Поскольку блоки предоставляют потоки, может возникнуть соблазн создать блок,
который прослушивает другой блок. Вы **не должны** делать этого. Существуют
лучшие альтернативы, чем прибегание к коду ниже:

<BlocTightCouplingSnippet />

Хотя приведенный выше код не содержит ошибок (и даже очищается за собой), у него
есть более серьезная проблема: он создает зависимость между двумя блоками.

Как правило, зависимостей между двумя сущностями на одном архитектурном слое
следует избегать любой ценой, так как это создает жесткую связь, которую трудно
поддерживать. Поскольку блоки находятся на архитектурном слое бизнес-логики, ни
один блок не должен знать о каком-либо другом блоке.

![Слои архитектуры приложения](~/assets/architecture/architecture.png)

Блок должен получать информацию только через события и из внедренных
репозиториев (то есть репозиториев, переданных блоку в его конструкторе).

Если вы находитесь в ситуации, когда блок должен реагировать на другой блок, у
вас есть два других варианта. Вы можете переместить проблему на слой выше (в
слой представления) или на слой ниже (в слой домена).

#### Соединение блоков через представление

Вы можете использовать `BlocListener` для прослушивания одного блока и
добавления события в другой блок всякий раз, когда первый блок изменяется.

<BlocLooseCouplingPresentationSnippet />

Приведенный выше код предотвращает необходимость `SecondBloc` знать о
`FirstBloc`, поощряя слабую связь. Приложение
[flutter_weather](/ru/tutorials/flutter-weather)
[использует эту технику](https://github.com/felangel/bloc/blob/b4c8db938ad71a6b60d4a641ec357905095c3965/examples/flutter_weather/lib/weather/view/weather_page.dart#L38-L42)
для изменения темы приложения на основе полученной информации о погоде.

В некоторых ситуациях вы можете не захотеть связывать два блока в слое
представления. Вместо этого часто имеет смысл, чтобы два блока использовали один
и тот же источник данных и обновлялись при изменении данных.

#### Соединение блоков через домен

Два блока могут прослушивать поток из репозитория и обновлять свои состояния
независимо друг от друга всякий раз, когда изменяются данные репозитория.
Использование реактивных репозиториев для синхронизации состояния является
обычным делом в крупномасштабных корпоративных приложениях.

Сначала создайте или используйте репозиторий, который предоставляет `Stream`
данных. Например, следующий репозиторий предоставляет бесконечный поток одних и
тех же нескольких идей приложений:

<AppIdeasRepositorySnippet />

Один и тот же репозиторий может быть внедрен в каждый блок, который должен
реагировать на новые идеи приложений. Ниже приведен `AppIdeaRankingBloc`,
который выдает состояние для каждой входящей идеи приложения из репозитория
выше:

<AppIdeaRankingBlocSnippet />

Подробнее об использовании потоков с Bloc см. в статье
[Как использовать Bloc с потоками и параллелизмом](https://verygood.ventures/blog/how-to-use-bloc-with-streams-and-concurrency).

## Слой представления

Ответственность слоя представления заключается в определении того, как
отрисовать себя на основе одного или нескольких состояний блоков. Кроме того, он
должен обрабатывать ввод пользователя и события жизненного цикла приложения.

Большинство потоков приложений начинаются с события `AppStart`, которое
запускает приложение для получения некоторых данных для представления
пользователю.

В этом сценарии слой представления добавит событие `AppStart`.

Кроме того, слой представления должен будет выяснить, что отрисовать на экране
на основе состояния из слоя bloc.

<PresentationComponentSnippet />

До сих пор, хотя у нас были некоторые фрагменты кода, все это было довольно
высокоуровневым. В разделе руководств мы объединим все это вместе, когда будем
создавать несколько различных примеров приложений.
