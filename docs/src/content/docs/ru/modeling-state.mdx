---
title: Моделирование состояния
description:
  Обзор нескольких способов моделирования состояний при использовании
  package:bloc.
---

import ConcreteClassAndStatusEnumSnippet from '~/components/modeling-state/ConcreteClassAndStatusEnumSnippet.astro';
import SealedClassAndSubclassesSnippet from '~/components/modeling-state/SealedClassAndSubclassesSnippet.astro';

Существует множество различных подходов к структурированию состояния приложения.
Каждый из них имеет свои преимущества и недостатки. В этом разделе мы рассмотрим
несколько подходов, их плюсы и минусы, а также когда использовать каждый из них.

Следующие подходы являются просто рекомендациями и являются полностью
необязательными. Не стесняйтесь использовать любой подход, который вы
предпочитаете. Вы можете обнаружить, что некоторые примеры/документация не
следуют подходам в основном для простоты/краткости.

:::tip

Следующие фрагменты кода сосредоточены на структуре состояния. На практике вы
также можете захотеть:

- Расширить `Equatable` из
  [`package:equatable`](https://pub.dev/packages/equatable)
- Аннотировать класс с помощью `@Data()` из
  [`package:data_class`](https://pub.dev/packages/data_class)
- Аннотировать класс с помощью **@immutable** из
  [`package:meta`](https://pub.dev/packages/meta)
- Реализовать метод `copyWith`
- Использовать ключевое слово `const` для конструкторов

:::

## Конкретный класс и enum статуса

Этот подход состоит из **одного конкретного класса** для всех состояний вместе с
`enum`, представляющим различные статусы. Свойства делаются nullable и
обрабатываются на основе текущего статуса. Этот подход лучше всего работает для
состояний, которые не являются строго эксклюзивными и/или содержат много общих
свойств.

<ConcreteClassAndStatusEnumSnippet />

#### Плюсы

- **Просто**: Легко управлять одним классом и enum статуса, и все свойства легко
  доступны.
- **Кратко**: Обычно требует меньше строк кода по сравнению с другими подходами.

#### Минусы

- **Не типобезопасно**: Требует проверки `status` перед доступом к свойствам.
  Возможно `emit` неправильно сформированное состояние, что может привести к
  ошибкам. Свойства для конкретных состояний являются nullable, что может быть
  обременительным для управления и требует либо принудительного извлечения, либо
  выполнения проверок на null. Некоторые из этих минусов могут быть смягчены
  написанием модульных тестов и написанием специализированных именованных
  конструкторов.
- **Раздутый**: Приводит к одному состоянию, которое может стать раздутым с
  множеством свойств со временем.

#### Вердикт

Этот подход лучше всего работает для простых состояний или когда требования
требуют состояний, которые не являются эксклюзивными (например, показ snackbar
при возникновении ошибки при сохранении старых данных из последнего успешного
состояния). Этот подход обеспечивает гибкость и краткость за счет
типобезопасности.

## Запечатанный класс и подклассы

Этот подход состоит из **запечатанного класса**, который содержит любые общие
свойства, и нескольких подклассов для отдельных состояний. Этот подход отлично
подходит для раздельных эксклюзивных состояний.

<SealedClassAndSubclassesSnippet />

#### Плюсы

- **Типобезопасно**: Код безопасен на этапе компиляции, и невозможно случайно
  получить доступ к недопустимому свойству. Каждый подкласс содержит свои
  собственные свойства, что делает ясным, какие свойства принадлежат какому
  состоянию.
- **Явно:** Разделяет общие свойства от специфичных для состояния свойств.
- **Исчерпывающе**: Использование оператора `switch` для проверки
  исчерпывающести, чтобы гарантировать, что каждое состояние явно обработано.
  - Если вы не хотите
    [исчерпывающего переключения](https://dart.dev/language/branches#exhaustiveness-checking)
    или хотите иметь возможность добавлять подтипы позже без нарушения API,
    используйте модификатор
    [final](https://dart.dev/language/class-modifiers#final).
  - См.
    [документацию по запечатанным классам](https://dart.dev/language/class-modifiers#sealed)
    для получения более подробной информации.

#### Минусы

- **Многословно**: Требует больше кода (один базовый класс и подкласс для
  каждого состояния). Также может потребоваться дублирование кода для общих
  свойств в подклассах.
- **Сложно**: Добавление новых свойств требует обновления каждого подкласса и
  базового класса, что может быть обременительным и привести к увеличению
  сложности состояния. Кроме того, может потребоваться ненужная/избыточная
  проверка типов для доступа к свойствам.

#### Вердикт

Этот подход лучше всего работает для хорошо определенных эксклюзивных состояний
с уникальными свойствами. Этот подход обеспечивает типобезопасность и
исчерпывающие проверки и подчеркивает безопасность над краткостью и простотой.
