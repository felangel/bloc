---
title: Нескінченний список Flutter
description:
  Детальний посібник зі створення нескінченного списку на Flutter з
  використанням bloc.
sidebar:
  order: 3
---

import RemoteCode from '~/components/code/RemoteCode.astro';
import FlutterCreateSnippet from '~/components/tutorials/flutter-infinite-list/FlutterCreateSnippet.astro';
import FlutterPubGetSnippet from '~/components/tutorials/flutter-infinite-list/FlutterPubGetSnippet.astro';
import PostsJsonSnippet from '~/components/tutorials/flutter-infinite-list/PostsJsonSnippet.astro';
import PostBlocInitialStateSnippet from '~/components/tutorials/flutter-infinite-list/PostBlocInitialStateSnippet.astro';
import PostBlocOnPostFetchedSnippet from '~/components/tutorials/flutter-infinite-list/PostBlocOnPostFetchedSnippet.astro';
import PostBlocTransformerSnippet from '~/components/tutorials/flutter-infinite-list/PostBlocTransformerSnippet.astro';

![intermediate](https://img.shields.io/badge/level-intermediate-orange.svg)

У цьому підручнику ми реалізуємо додаток, який завантажує дані з мережі та
відображає їх у міру прокручування користувачем, використовуючи Flutter та
бібліотеку bloc.

![demo](~/assets/tutorials/flutter-infinite-list.gif)

## Ключові теми

- Спостереження за змінами стану за допомогою
  [BlocObserver](/uk/bloc-concepts#blocobserver).
- [BlocProvider](/uk/flutter-bloc-concepts#blocprovider), віджет Flutter, який
  надає bloc своїм дочірнім елементам.
- [BlocBuilder](/uk/flutter-bloc-concepts#blocbuilder), віджет Flutter, який
  обробляє побудову віджета у відповідь на нові стани.
- Додавання подій за допомогою
  [context.read](/uk/flutter-bloc-concepts#contextread).
- Запобігання зайвим перебудовам за допомогою
  [Equatable](/uk/faqs#коли-використовувати-equatable).
- Використання методу `transformEvents` з Rx.

## Налаштування

Почнемо зі створення нового Flutter проєкту

<FlutterCreateSnippet />

Потім ми можемо замінити вміст pubspec.yaml на

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/pubspec.yaml"
	title="pubspec.yaml"
/>

а потім встановити всі наші залежності

<FlutterPubGetSnippet />

## Структура проєкту

```
├── lib
|   ├── posts
│   │   ├── bloc
│   │   │   └── post_bloc.dart
|   |   |   └── post_event.dart
|   |   |   └── post_state.dart
|   |   └── models
|   |   |   └── models.dart*
|   |   |   └── post.dart
│   │   └── view
│   │   |   ├── posts_page.dart
│   │   |   └── posts_list.dart
|   |   |   └── view.dart*
|   |   └── widgets
|   |   |   └── bottom_loader.dart
|   |   |   └── post_list_item.dart
|   |   |   └── widgets.dart*
│   │   ├── posts.dart*
│   ├── app.dart
│   ├── simple_bloc_observer.dart
│   └── main.dart
├── pubspec.lock
├── pubspec.yaml
```

Додаток використовує структуру каталогів, орієнтовану на функціональність. Ця
структура проєкту дозволяє нам масштабувати проєкт, маючи самодостатні
функціональні модулі. У цьому прикладі ми матимемо лише один модуль (модуль
постів), який розділений на відповідні каталоги з barrel-файлами, позначеними
зірочкою (\*).

## REST API

Для цього демо-додатку ми використаємо
[jsonplaceholder](http://jsonplaceholder.typicode.com) як джерело даних.

:::note

jsonplaceholder — це онлайн REST API, який надає фейкові дані; він дуже корисний
для створення прототипів.

:::

Відкрийте нову вкладку у браузері та перейдіть за адресою
https://jsonplaceholder.typicode.com/posts?_start=0&_limit=2, щоб побачити, що
повертає API.

<PostsJsonSnippet />

:::note

У нашому URL ми вказали start та limit як параметри запиту для GET-запиту.

:::

Чудово, тепер, коли ми знаємо, як виглядатимуть наші дані, створимо модель.

## Модель даних

Створіть `post.dart` і почнемо створювати модель нашого об'єкта Post.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/models/post.dart"
	title="lib/posts/models/post.dart"
/>

`Post` — це просто клас з `id`, `title` та `body`.

:::note

Ми розширюємо [`Equatable`](https://pub.dev/packages/equatable), щоб мати
можливість порівнювати `Post`. Без цього нам довелося б вручну змінювати наш
клас для перевизначення рівності та hashCode, щоб відрізняти два об'єкти `Post`.
Дивіться [пакет](https://pub.dev/packages/equatable) для детальної інформації.

:::

Тепер, коли у нас є модель об'єкта `Post`, почнемо працювати над компонентом
бізнес-логіки (bloc).

## Post Events

Перш ніж зануритися в реалізацію, нам потрібно визначити, що буде робити наш
`PostBloc`.

На високому рівні він реагуватиме на введення користувача (прокручування) та
завантажуватиме більше постів, щоб шар представлення міг їх відобразити. Почнемо
зі створення нашої `Event`.

Наш `PostBloc` реагуватиме лише на одну подію — `PostFetched`, яку буде додавати
шар представлення, коли йому потрібно більше постів для відображення. Оскільки
наш `PostFetched` є типом `PostEvent`, ми можемо створити `bloc/post_event.dart`
та реалізувати подію так.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/bloc/post_event.dart"
	title="lib/posts/bloc/post_event.dart"
/>

Підсумовуючи, наш `PostBloc` отримуватиме `PostEvents` та перетворюватиме їх на
`PostStates`. Ми визначили всі наші `PostEvents` (PostFetched), тому далі
визначимо наш `PostState`.

## Post States

Наш шар представлення потребуватиме кілька фрагментів інформації для коректного
відображення:

- `PostInitial` — повідомляє шар представлення, що потрібно відобразити
  індикатор завантаження під час завантаження початкової партії постів
- `PostSuccess` — повідомляє шар представлення, що є контент для відображення
  - `posts` — буде `List<Post>`, який відображатиметься
  - `hasReachedMax` — повідомляє шар представлення, чи досягнуто максимальну
    кількість постів
- `PostFailure` — повідомляє шар представлення, що сталася помилка під час
  завантаження постів

Тепер ми можемо створити `bloc/post_state.dart` та реалізувати його так.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/bloc/post_state.dart"
	title="lib/posts/bloc/post_state.dart"
/>

:::note

Ми реалізували `copyWith`, щоб мати можливість копіювати екземпляр `PostSuccess`
та зручно оновлювати нуль або більше властивостей (це знадобиться пізніше).

:::

Тепер, коли ми реалізували наші `Events` та `States`, можемо створити наш
`PostBloc`.

## Post Bloc

Для простоти наш `PostBloc` матиме пряму залежність від `http client`; однак у
продакшн-додатку ми рекомендуємо замість цього впроваджувати api клієнт та
використовувати патерн репозиторій [документація](/uk/architecture).

Створимо `post_bloc.dart` та наш порожній `PostBloc`.

<PostBlocInitialStateSnippet />

:::note

Лише з оголошення класу ми бачимо, що наш PostBloc прийматиме PostEvents як вхід
та виводитиме PostStates.

:::

Далі нам потрібно зареєструвати обробник подій для обробки вхідних подій
`PostFetched`. У відповідь на подію `PostFetched` ми викликатимемо `_fetchPosts`
для завантаження постів з API.

<PostBlocOnPostFetchedSnippet />

Наш `PostBloc` буде `emit` нові стани через `Emitter<PostState>`, наданий в
обробнику подій. Перегляньте
[основні концепції](/uk/bloc-concepts#потоки-streams) для детальної інформації.

Тепер кожного разу, коли додається `PostEvent`, якщо це подія `PostFetched` і є
ще пости для завантаження, наш `PostBloc` завантажить наступні 20 постів.

API поверне порожній масив, якщо ми спробуємо завантажити більше максимальної
кількості постів (100), тому якщо ми отримаємо порожній масив, наш bloc
`emit`-не поточний стан, але встановить `hasReachedMax` у true.

Якщо ми не можемо отримати пости, ми випускаємо `PostStatus.failure`.

Якщо ми можемо отримати пости, ми випускаємо `PostStatus.success` та весь список
постів.

Одна оптимізація, яку ми можемо зробити — це `throttle` подій `PostFetched`, щоб
не спамити наш API без потреби. Ми можемо це зробити, використовуючи параметр
`transform` при реєстрації обробника подій `_onFetched`.

:::note

Передача `transformer` до `on<PostFetched>` дозволяє налаштувати спосіб обробки
подій.

:::

:::note

Переконайтеся, що імпортували
[`package:stream_transform`](https://pub.dev/packages/stream_transform) для
використання API `throttle`.

:::

<PostBlocTransformerSnippet />

Наш завершений `PostBloc` тепер має виглядати так:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/bloc/post_bloc.dart"
	title="lib/posts/bloc/post_bloc.dart"
/>

Чудово! Тепер, коли ми завершили реалізацію бізнес-логіки, залишилося
реалізувати шар представлення.

## Шар представлення

У нашому `main.dart` ми можемо почати з реалізації головної функції та виклику
`runApp` для відображення нашого кореневого віджета. Тут ми також можемо
підключити наш bloc observer для логування переходів та помилок.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/main.dart"
	title="lib/main.dart"
/>

У нашому віджеті `App`, кореневому елементі нашого проєкту, ми можемо встановити
home як `PostsPage`

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/app.dart"
	title="lib/app.dart"
/>

У нашому віджеті `PostsPage` ми використовуємо `BlocProvider` для створення та
надання екземпляра `PostBloc` піддереву. Також ми додаємо подію `PostFetched`,
щоб при завантаженні додатку він запитав початкову партію постів.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/view/posts_page.dart"
	title="lib/posts/view/posts_page.dart"
/>

Далі нам потрібно реалізувати наше представлення `PostsList`, яке відображатиме
наші пости та підключатиметься до нашого `PostBloc`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/view/posts_list.dart"
	title="lib/posts/view/posts_list.dart"
/>

:::note

`PostsList` є `StatefulWidget`, оскільки потребує підтримки `ScrollController`.
У `initState` ми додаємо слухача до нашого `ScrollController`, щоб реагувати на
події прокручування. Також ми отримуємо екземпляр `PostBloc` через
`context.read<PostBloc>()`.

:::

Далі наш метод build повертає `BlocBuilder`. `BlocBuilder` — це віджет Flutter з
пакету [flutter_bloc](https://pub.dev/packages/flutter_bloc), який обробляє
побудову віджета у відповідь на нові стани bloc. Кожного разу, коли змінюється
стан нашого `PostBloc`, функція builder буде викликана з новим `PostState`.

:::caution

Нам потрібно пам'ятати про очищення ресурсів та утилізацію нашого
`ScrollController`, коли StatefulWidget утилізується.

:::

Кожного разу, коли користувач прокручує, ми обчислюємо, наскільки далеко він
прокрутив сторінку, і якщо наша відстань >= 90% нашого `maxScrollExtent`, ми
додаємо подію `PostFetched` для завантаження більше постів.

Далі нам потрібно реалізувати наш віджет `BottomLoader`, який показуватиме
користувачу, що ми завантажуємо більше постів.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/widgets/bottom_loader.dart"
	title="lib/posts/widgets/bottom_loader.dart"
/>

Нарешті, нам потрібно реалізувати наш `PostListItem`, який відображатиме окремий
`Post`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/posts/widgets/post_list_item.dart"
	title="lib/posts/widgets/post_list_item.dart"
/>

На цьому етапі ми повинні мати можливість запустити наш додаток, і все має
працювати; однак є ще одна річ, яку ми можемо зробити.

Додатковою перевагою використання бібліотеки bloc є те, що ми можемо мати доступ
до всіх `Transitions` в одному місці.

Зміна від одного стану до іншого називається `Transition`.

:::note

`Transition` складається з поточного стану, події та наступного стану.

:::

Навіть хоча в цьому додатку ми маємо лише один bloc, у більших додатках досить
поширено мати багато блоків, що керують різними частинами стану додатку.

Якщо ми хочемо мати можливість виконувати дії у відповідь на всі `Transitions`,
ми можемо просто створити наш власний `BlocObserver`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_infinite_list/lib/simple_bloc_observer.dart"
	title="lib/simple_bloc_observer.dart"
/>

:::note

Все, що нам потрібно зробити — це розширити `BlocObserver` та перевизначити
метод `onTransition`.

:::

Тепер кожного разу, коли відбувається `Transition` Bloc, ми бачитимемо перехід,
виведений у консоль.

:::note

На практиці ви можете створювати різні `BlocObservers`, і оскільки кожна зміна
стану записується, ми можемо дуже легко інструментувати наші додатки та
відстежувати всі взаємодії користувачів та зміни стану в одному місці!

:::

Ось і все! Ми успішно реалізували нескінченний список у Flutter, використовуючи
пакети [bloc](https://pub.dev/packages/bloc) та
[flutter_bloc](https://pub.dev/packages/flutter_bloc), і ми успішно відокремили
наш шар представлення від бізнес-логіки.

Наш `PostsPage` не знає, звідки беруться `Post` і як вони отримуються. І
навпаки, наш `PostBloc` не знає, як відображається `State`, він просто
перетворює події на стани.

Повний вихідний код цього прикладу можна знайти
[тут](https://github.com/felangel/Bloc/tree/master/examples/flutter_infinite_list).
