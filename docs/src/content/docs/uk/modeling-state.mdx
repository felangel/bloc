---
title: Моделювання стану
description:
  Огляд кількох способів моделювання станів при використанні package:bloc.
---

import ConcreteClassAndStatusEnumSnippet from '~/components/modeling-state/ConcreteClassAndStatusEnumSnippet.astro';
import SealedClassAndSubclassesSnippet from '~/components/modeling-state/SealedClassAndSubclassesSnippet.astro';

Існує безліч різних підходів до структурування стану додатку. Кожен з них має
свої переваги та недоліки. У цьому розділі ми розглянемо кілька підходів, їх
плюси та мінуси, а також коли використовувати кожен з них.

Наведені нижче підходи є лише рекомендаціями і є повністю необов'язковими.
Використовуйте будь-який підхід, який вам подобається. Ви можете виявити, що
деякі приклади/документація не дотримуються цих підходів, переважно для
простоти/стислості.

:::tip

Наведені нижче фрагменти коду зосереджені на структурі стану. На практиці ви
також можете захотіти:

- Розширити `Equatable` з
  [`package:equatable`](https://pub.dev/packages/equatable)
- Анотувати клас за допомогою `@Data()` з
  [`package:data_class`](https://pub.dev/packages/data_class)
- Анотувати клас за допомогою **@immutable** з
  [`package:meta`](https://pub.dev/packages/meta)
- Реалізувати метод `copyWith`
- Використовувати ключове слово `const` для конструкторів

:::

## Конкретний клас та enum статусу

Цей підхід складається з **одного конкретного класу** для всіх станів разом з
`enum`, що представляє різні статуси. Властивості робляться nullable і
обробляються на основі поточного статусу. Цей підхід найкраще працює для станів,
які не є строго ексклюзивними та/або містять багато спільних властивостей.

<ConcreteClassAndStatusEnumSnippet />

#### Плюси

- **Просто**: Легко керувати одним класом та enum статусу, і всі властивості
  легко доступні.
- **Стисло**: Зазвичай потребує менше рядків коду порівняно з іншими підходами.

#### Мінуси

- **Не типобезпечно**: Потребує перевірки `status` перед доступом до
  властивостей. Можливо `emit` неправильно сформований стан, що може призвести
  до помилок. Властивості для конкретних станів є nullable, що може бути
  обтяжливим для керування і потребує або примусового розгортання, або виконання
  перевірок на null. Деякі з цих мінусів можна пом'якшити написанням модульних
  тестів та написанням спеціалізованих іменованих конструкторів.
- **Роздутий**: Призводить до одного стану, який може стати роздутим з багатьма
  властивостями з часом.

#### Вердикт

Цей підхід найкраще працює для простих станів або коли вимоги потребують станів,
які не є ексклюзивними (наприклад, показ snackbar при виникненні помилки при
збереженні старих даних з останнього успішного стану). Цей підхід забезпечує
гнучкість та стислість за рахунок типобезпеки.

## Запечатаний клас та підкласи

Цей підхід складається з **запечатаного класу**, який містить будь-які спільні
властивості, та кількох підкласів для окремих станів. Цей підхід чудово
підходить для окремих, ексклюзивних станів.

<SealedClassAndSubclassesSnippet />

#### Плюси

- **Типобезпечно**: Код безпечний на етапі компіляції, і неможливо випадково
  отримати доступ до недопустимої властивості. Кожен підклас містить свої власні
  властивості, що робить зрозумілим, які властивості належать якому стану.
- **Явно:** Розділяє спільні властивості від специфічних для стану властивостей.
- **Вичерпно**: Використання оператора `switch` для перевірки вичерпності, щоб
  гарантувати, що кожен стан явно оброблений.
  - Якщо ви не хочете
    [вичерпного перемикання](https://dart.dev/language/branches#exhaustiveness-checking)
    або хочете мати можливість додавати підтипи пізніше без порушення API,
    використовуйте модифікатор
    [final](https://dart.dev/language/class-modifiers#final).
  - Див.
    [документацію по запечатаних класах](https://dart.dev/language/class-modifiers#sealed)
    для отримання детальнішої інформації.

#### Мінуси

- **Багатослівно**: Потребує більше коду (один базовий клас та підклас для
  кожного стану). Також може потребувати дублювання коду для спільних
  властивостей у підкласах.
- **Складно**: Додавання нових властивостей потребує оновлення кожного підкласу
  та базового класу, що може бути обтяжливим і призвести до збільшення
  складності стану. Крім того, може потребувати непотрібної/надмірної перевірки
  типів для доступу до властивостей.

#### Вердикт

Цей підхід найкраще працює для добре визначених ексклюзивних станів з
унікальними властивостями. Цей підхід забезпечує типобезпеку та вичерпні
перевірки і наголошує на безпеці над стислістю та простотою.
