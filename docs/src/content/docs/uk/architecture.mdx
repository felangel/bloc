---
title: Архітектура
description: Огляд рекомендованих архітектурних шаблонів при використанні bloc.
---

import DataProviderSnippet from '~/components/architecture/DataProviderSnippet.astro';
import RepositorySnippet from '~/components/architecture/RepositorySnippet.astro';
import BusinessLogicComponentSnippet from '~/components/architecture/BusinessLogicComponentSnippet.astro';
import BlocTightCouplingSnippet from '~/components/architecture/BlocTightCouplingSnippet.astro';
import BlocLooseCouplingPresentationSnippet from '~/components/architecture/BlocLooseCouplingPresentationSnippet.astro';
import AppIdeasRepositorySnippet from '~/components/architecture/AppIdeasRepositorySnippet.astro';
import AppIdeaRankingBlocSnippet from '~/components/architecture/AppIdeaRankingBlocSnippet.astro';
import PresentationComponentSnippet from '~/components/architecture/PresentationComponentSnippet.astro';

![Архітектура Bloc](~/assets/concepts/bloc_architecture_full.png)

Використання бібліотеки bloc дозволяє нам розділити наш додаток на три шари:

- Представлення
- Бізнес-логіка
- Дані
  - Сховище
  - Постачальник даних

Ми почнемо з найнижчого шару (найбільш віддаленого від користувацького
інтерфейсу) та рухатимемося вгору до шару представлення.

## Шар даних

Відповідальність шару даних полягає в отриманні/маніпулюванні даними з одного
або кількох джерел.

Шар даних можна розділити на дві частини:

- Сховище
- Постачальник даних

Цей шар є найнижчим рівнем додатку та взаємодіє з базами даних, мережевими
запитами та іншими асинхронними джерелами даних.

### Постачальник даних

Відповідальність постачальника даних полягає в наданні необроблених даних.
Постачальник даних повинен бути універсальним та багатофункціональним.

Постачальник даних зазвичай надає прості API для виконання
[CRUD](https://uk.wikipedia.org/wiki/CRUD) операцій. Ми можемо мати методи
`createData`, `readData`, `updateData` та `deleteData` як частину нашого шару
даних.

<DataProviderSnippet />

### Сховище

Шар сховища — це обгортка навколо одного або кількох постачальників даних, з
якими спілкується шар Bloc.

<RepositorySnippet />

Як ви можете бачити, наш шар сховища може взаємодіяти з кількома постачальниками
даних та виконувати перетворення даних перед передачею результату на шар
бізнес-логіки.

## Шар бізнес-логіки

Відповідальність шару бізнес-логіки полягає у відповіді на введення з шару
представлення новими станами. Цей шар може залежати від одного або кількох
сховищ для отримання даних, необхідних для побудови стану додатку.

Думайте про шар бізнес-логіки як про міст між користувацьким інтерфейсом (шар
представлення) та шаром даних. Шар бізнес-логіки сповіщається про
події/дії з шару представлення, а потім взаємодіє зі сховищем, щоб побудувати
новий стан для використання шаром представлення.

<BusinessLogicComponentSnippet />

### Взаємодія між блоками

Оскільки блоки надають потоки, може виникнути спокуса створити блок, який
прослуховує інший блок. Ви **не повинні** робити цього. Існують кращі
альтернативи, ніж вдаватися до коду нижче:

<BlocTightCouplingSnippet />

Хоча наведений вище код не містить помилок (і навіть очищується за собою), він
має більш серйозну проблему: він створює залежність між двома блоками.

Як правило, залежностей між двома сутностями на одному архітектурному шарі слід
уникати за будь-яку ціну, оскільки це створює тісний зв'язок, який важко
підтримувати. Оскільки блоки знаходяться на архітектурному шарі бізнес-логіки,
жоден блок не повинен знати про будь-який інший блок.

![Шари архітектури додатку](~/assets/architecture/architecture.png)

Блок повинен отримувати інформацію лише через події та з впроваджених сховищ
(тобто сховищ, переданих блоку в його конструкторі).

Якщо ви перебуваєте в ситуації, коли блок повинен реагувати на інший блок, у вас
є два інших варіанти. Ви можете перемістити проблему на шар вище (у шар
представлення) або на шар нижче (у шар домену).

#### З'єднання блоків через представлення

Ви можете використовувати `BlocListener` для прослуховування одного блоку та
додавання події до іншого блоку щоразу, коли перший блок змінюється.

<BlocLooseCouplingPresentationSnippet />

Наведений вище код запобігає необхідності `SecondBloc` знати про `FirstBloc`,
заохочуючи слабкий зв'язок. Додаток
[flutter_weather](/uk/tutorials/flutter-weather)
[використовує цю техніку](https://github.com/felangel/bloc/blob/b4c8db938ad71a6b60d4a641ec357905095c3965/examples/flutter_weather/lib/weather/view/weather_page.dart#L38-L42)
для зміни теми додатку на основі отриманої інформації про погоду.

У деяких ситуаціях ви можете не захотіти зв'язувати два блоки в шарі
представлення. Замість цього часто має сенс, щоб два блоки використовували одне
й те саме джерело даних та оновлювалися при зміні даних.

#### З'єднання блоків через домен

Два блоки можуть прослуховувати потік зі сховища та оновлювати свої стани
незалежно один від одного щоразу, коли змінюються дані сховища. Використання
реактивних сховищ для синхронізації стану є поширеним у великомасштабних
корпоративних додатках.

Спочатку створіть або використовуйте сховище, яке надає `Stream` даних.
Наприклад, наступне сховище надає нескінченний потік тих самих кількох ідей
додатків:

<AppIdeasRepositorySnippet />

Те саме сховище може бути впроваджене в кожний блок, який повинен реагувати на
нові ідеї додатків. Нижче наведено `AppIdeaRankingBloc`, який видає стан для
кожної вхідної ідеї додатку зі сховища вище:

<AppIdeaRankingBlocSnippet />

Докладніше про використання потоків з Bloc див. у статті
[Як використовувати Bloc з потоками та конкурентністю](https://verygood.ventures/blog/how-to-use-bloc-with-streams-and-concurrency).

## Шар представлення

Відповідальність шару представлення полягає у визначенні того, як відмалювати
себе на основі одного або кількох станів блоків. Крім того, він повинен
обробляти введення користувача та події життєвого циклу додатку.

Більшість потоків додатків починаються з події `AppStart`, яка запускає додаток
для отримання деяких даних для представлення користувачеві.

У цьому сценарії шар представлення додасть подію `AppStart`.

Крім того, шар представлення повинен буде визначити, що відмалювати на екрані на
основі стану з шару bloc.

<PresentationComponentSnippet />

До цього моменту, хоча у нас були деякі фрагменти коду, все це було досить
високорівневим. У розділі посібників ми об'єднаємо все це разом, коли будемо
створювати кілька різних прикладів додатків.
