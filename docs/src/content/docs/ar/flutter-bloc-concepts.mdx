---
title: مفاهيم Flutter Bloc
description: نظرة عامة على المفاهيم الأساسية لحزمة flutter_bloc.
sidebar:
  order: 2
---

import BlocBuilderSnippet from '~/components/concepts/flutter-bloc/BlocBuilderSnippet.astro';
import BlocBuilderExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocBuilderExplicitBlocSnippet.astro';
import BlocBuilderConditionSnippet from '~/components/concepts/flutter-bloc/BlocBuilderConditionSnippet.astro';
import BlocSelectorSnippet from '~/components/concepts/flutter-bloc/BlocSelectorSnippet.astro';
import BlocProviderSnippet from '~/components/concepts/flutter-bloc/BlocProviderSnippet.astro';
import BlocProviderEagerSnippet from '~/components/concepts/flutter-bloc/BlocProviderEagerSnippet.astro';
import BlocProviderValueSnippet from '~/components/concepts/flutter-bloc/BlocProviderValueSnippet.astro';
import BlocProviderLookupSnippet from '~/components/concepts/flutter-bloc/BlocProviderLookupSnippet.astro';
import NestedBlocProviderSnippet from '~/components/concepts/flutter-bloc/NestedBlocProviderSnippet.astro';
import MultiBlocProviderSnippet from '~/components/concepts/flutter-bloc/MultiBlocProviderSnippet.astro';
import BlocListenerSnippet from '~/components/concepts/flutter-bloc/BlocListenerSnippet.astro';
import BlocListenerExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocListenerExplicitBlocSnippet.astro';
import BlocListenerConditionSnippet from '~/components/concepts/flutter-bloc/BlocListenerConditionSnippet.astro';
import NestedBlocListenerSnippet from '~/components/concepts/flutter-bloc/NestedBlocListenerSnippet.astro';
import MultiBlocListenerSnippet from '~/components/concepts/flutter-bloc/MultiBlocListenerSnippet.astro';
import BlocConsumerSnippet from '~/components/concepts/flutter-bloc/BlocConsumerSnippet.astro';
import BlocConsumerConditionSnippet from '~/components/concepts/flutter-bloc/BlocConsumerConditionSnippet.astro';
import RepositoryProviderSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderSnippet.astro';
import RepositoryProviderLookupSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderLookupSnippet.astro';
import RepositoryProviderDisposeSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderDisposeSnippet.astro';
import NestedRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/NestedRepositoryProviderSnippet.astro';
import MultiRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/MultiRepositoryProviderSnippet.astro';
import CounterBlocSnippet from '~/components/concepts/flutter-bloc/CounterBlocSnippet.astro';
import CounterMainSnippet from '~/components/concepts/flutter-bloc/CounterMainSnippet.astro';
import CounterPageSnippet from '~/components/concepts/flutter-bloc/CounterPageSnippet.astro';
import WeatherRepositorySnippet from '~/components/concepts/flutter-bloc/WeatherRepositorySnippet.astro';
import WeatherMainSnippet from '~/components/concepts/flutter-bloc/WeatherMainSnippet.astro';
import WeatherAppSnippet from '~/components/concepts/flutter-bloc/WeatherAppSnippet.astro';
import WeatherPageSnippet from '~/components/concepts/flutter-bloc/WeatherPageSnippet.astro';

:::note

يرجى التأكد من قراءة الأقسام التالية بعناية قبل البدء بالعمل مع حزمة
[`package:flutter_bloc`](https://pub.dev/packages/flutter_bloc).

:::

:::note

جميع الـ Widgets التي تصدرها حزمة `flutter_bloc` تتكامل مع كل من مثيلات `Cubit`
و `Bloc`.

:::

## Widgets الـ Bloc

### BlocBuilder

**BlocBuilder** هو ويدجت (Widget) في Flutter يتطلب `Bloc` ودالة `builder`.
يتعامل `BlocBuilder` مع بناء الـ Widget استجابةً للحالات الجديدة (new states).
يشبه `BlocBuilder` إلى حد كبير `StreamBuilder` لكنه يوفر واجهة (API) أبسط لتقليل
كمية الكود المتكرر (boilerplate) المطلوبة. قد يتم استدعاء دالة `builder` مرات
عديدة، لذلك يُفضل أن تكون
[دالة نقية (pure function)](https://en.wikipedia.org/wiki/Pure_function) تعيد
ويدجت استجابةً للحالة.

راجع `BlocListener` إذا كنت تريد "تنفيذ" شيء استجابةً لتغيرات الحالة مثل التنقل
(navigation) أو إظهار مربع حوار (dialog) وغيرها.

إذا تم حذف معامل `bloc`، فسيقوم `BlocBuilder` تلقائيًا بإجراء بحث (lookup)
باستخدام `BlocProvider` و `BuildContext` الحالي.

<BlocBuilderSnippet />

قم بتحديد الـ bloc فقط إذا كنت ترغب في توفير bloc سيكون نطاقه (scoped) مقتصرًا
على ويدجت واحد ولا يمكن الوصول إليه عبر `BlocProvider` أبوي و `BuildContext`
الحالي.

<BlocBuilderExplicitBlocSnippet />

لتحكم أدق في وقت استدعاء دالة `builder`، يمكن تمرير دالة اختيارية `buildWhen`.
تأخذ `buildWhen` حالة الـ bloc السابقة والحالة الحالية وتعيد قيمة منطقية
(boolean). إذا أعادت `true` فسيتم استدعاء `builder` وإعادة بناء الـ Widget، وإذا
أعادت `false` فلن يتم استدعاء `builder` ولن تحدث إعادة بناء.

<BlocBuilderConditionSnippet />

### BlocSelector

**BlocSelector** هو ويدجت في Flutter يشبه `BlocBuilder` لكنه يسمح بتصفية
التحديثات عبر اختيار قيمة جديدة بناءً على حالة الـ bloc الحالية. يتم منع عمليات
البناء غير الضرورية إذا لم تتغير القيمة المختارة. يجب أن تكون القيمة المختارة
غير قابلة للتغيير (immutable) حتى يتمكن `BlocSelector` من تحديد ما إذا كان يجب
استدعاء `builder` مجددًا بدقة.

إذا تم حذف معامل `bloc`، فسيقوم `BlocSelector` تلقائيًا بإجراء بحث باستخدام
`BlocProvider` و `BuildContext` الحالي.

<BlocSelectorSnippet />

### BlocProvider

**BlocProvider** هو ويدجت في Flutter يوفر bloc لأبنائه عبر
`BlocProvider.of<T>(context)`. يُستخدم كويدجت لحقن التبعية (Dependency
Injection - DI) بحيث يمكن توفير مثيل واحد من الـ bloc لعدة ويدجتات داخل شجرة
فرعية (subtree).

في أغلب الحالات، يجب استخدام `BlocProvider` لإنشاء blocs جديدة ستكون متاحة لبقية
الشجرة الفرعية. وبما أن `BlocProvider` هو المسؤول عن الإنشاء، فسيتولى تلقائيًا
إغلاق الـ bloc.

<BlocProviderSnippet />

بشكل افتراضي، ينشئ `BlocProvider` الـ bloc بشكل كسول (lazily)، أي أن `create`
سيتم تنفيذه عند البحث عن الـ bloc عبر `BlocProvider.of<BlocA>(context)`.

لتجاوز هذا السلوك وإجبار `create` على العمل فورًا، يمكن تعيين `lazy` إلى
`false`.

<BlocProviderEagerSnippet />

في بعض الحالات، يمكن استخدام `BlocProvider` لتوفير bloc موجود بالفعل لجزء جديد
من شجرة الـ Widgets (مثلاً عند فتح Route جديد). في هذه الحالة، لن يقوم
`BlocProvider` بإغلاق الـ bloc تلقائيًا لأنه لم يقم بإنشائه.

<BlocProviderValueSnippet />

بعد ذلك، من أي من `ChildA` أو `ScreenA` يمكننا استرداد `BlocA` باستخدام:

<BlocProviderLookupSnippet />

### MultiBlocProvider

**MultiBlocProvider** هو ويدجت في Flutter يدمج عدة `BlocProvider` في ويدجت واحد.
يحسن قابلية القراءة ويزيل الحاجة إلى تداخل (nesting) عدة `BlocProvider`.
باستخدام `MultiBlocProvider` يمكننا الانتقال من:

<NestedBlocProviderSnippet />

إلى:

<MultiBlocProviderSnippet />

:::caution

عندما يتم تعريف `BlocProvider` ضمن سياق `MultiBlocProvider`، سيتم تجاهل أي
`child`.

:::

### BlocListener

**BlocListener** هو ويدجت في Flutter يأخذ `BlocWidgetListener` و `Bloc` اختياري،
ويستدعي `listener` استجابةً لتغيرات الحالة في الـ bloc. يُستخدم للوظائف التي يجب
أن تحدث مرة واحدة لكل تغيير حالة مثل التنقل، إظهار `SnackBar` أو `Dialog`.

يتم استدعاء `listener` مرة واحدة فقط لكل تغيير في الحالة (**لا** يشمل الحالة
الأولية) على عكس `builder` في `BlocBuilder`، وهو دالة `void`.

إذا تم حذف معامل `bloc`، فسيقوم `BlocListener` تلقائيًا بإجراء بحث باستخدام
`BlocProvider` و `BuildContext` الحالي.

<BlocListenerSnippet />

قم بتحديد الـ bloc فقط إذا كنت ترغب في توفير bloc لا يمكن الوصول إليه عبر
`BlocProvider` و `BuildContext` الحالي.

<BlocListenerExplicitBlocSnippet />

لتحكم أدق في وقت استدعاء `listener`، يمكن تمرير `listenWhen`. تأخذ `listenWhen`
حالة الـ bloc السابقة والحالة الحالية وتعيد قيمة منطقية. إذا أعادت `true` فسيتم
استدعاء `listener`، وإذا أعادت `false` فلن يتم استدعاؤه.

<BlocListenerConditionSnippet />

### MultiBlocListener

**MultiBlocListener** يدمج عدة `BlocListener` في ويدجت واحد لتحسين قابلية
القراءة وتجنب التداخل. باستخدامه يمكننا الانتقال من:

<NestedBlocListenerSnippet />

إلى:

<MultiBlocListenerSnippet />

:::caution

عندما يتم تعريف `BlocListener` ضمن سياق `MultiBlocListener`، سيتم تجاهل أي
`child`.

:::

### BlocConsumer

**BlocConsumer** يجمع بين `builder` و `listener` للتفاعل مع الحالات الجديدة.
يشبه استخدام `BlocListener` و `BlocBuilder` معًا لكنه يقلل من الكود المتكرر.
يُستخدم فقط عندما تحتاج إلى إعادة بناء UI وتنفيذ تفاعل آخر مع تغيرات الحالة في
نفس الوقت.

إذا تم حذف معامل `bloc`، فسيقوم `BlocConsumer` تلقائيًا بإجراء بحث باستخدام
`BlocProvider` و `BuildContext` الحالي.

<BlocConsumerSnippet />

يمكن تمرير `listenWhen` و `buildWhen` اختياريًا للتحكم بشكل أدق في وقت استدعاء
`listener` و `builder`. سيتم استدعاؤهما عند كل تغيير في `state` الخاص بالـ bloc.
كل منهما يأخذ الحالة السابقة والحالية ويعيد `bool`. إذا لم يتم توفيرهما فالقيمة
الافتراضية هي `true`.

<BlocConsumerConditionSnippet />

### RepositoryProvider

**RepositoryProvider** هو ويدجت في Flutter يوفر مستودعًا (repository) لأبنائه
عبر `RepositoryProvider.of<T>(context)`. يُستخدم لحقن التبعية (DI) لتوفير مثيل
واحد من المستودع لعدة ويدجتات داخل شجرة فرعية. يُستخدم `BlocProvider` للـ blocs
بينما يُستخدم `RepositoryProvider` للمستودعات فقط.

<RepositoryProviderSnippet />

ثم من `ChildA` يمكننا استرداد مثيل `Repository` باستخدام:

<RepositoryProviderLookupSnippet />

يمكن للمستودعات التي تدير موارد يجب التخلص منها (dispose) القيام بذلك عبر دالة
`dispose`:

<RepositoryProviderDisposeSnippet />

### MultiRepositoryProvider

**MultiRepositoryProvider** يدمج عدة `RepositoryProvider` في ويدجت واحد لتحسين
قابلية القراءة وتجنب التداخل. باستخدامه يمكننا الانتقال من:

<NestedRepositoryProviderSnippet />

إلى:

<MultiRepositoryProviderSnippet />

:::caution

عندما يتم تعريف `RepositoryProvider` ضمن سياق `MultiRepositoryProvider`، سيتم
تجاهل أي `child`.

:::

## استخدام BlocProvider

دعونا نلقي نظرة على كيفية استخدام `BlocProvider` لتوفير `CounterBloc` إلى
`CounterPage` والتفاعل مع تغيرات الحالة باستخدام `BlocBuilder`.

<CounterBlocSnippet />

<CounterMainSnippet />

<CounterPageSnippet />

في هذه المرحلة، نجحنا في فصل طبقة العرض (presentational layer) عن طبقة منطق
الأعمال (business logic layer). لاحظ أن ويدجت `CounterPage` لا يعرف شيئًا عما
يحدث عندما ينقر المستخدم على الأزرار. يخبر الـ Widget ببساطة `CounterBloc` بأن
المستخدم ضغط زر الزيادة أو النقصان.

## استخدام RepositoryProvider

سنلقي نظرة على كيفية استخدام `RepositoryProvider` ضمن سياق مثال
[`flutter_weather`][flutter_weather_link].

<WeatherRepositorySnippet />

في ملف `main.dart` نستدعي `runApp` مع ويدجت `WeatherApp`.

<WeatherMainSnippet />

سنقوم بحقن مثيل `WeatherRepository` في شجرة الـ Widgets عبر
`RepositoryProvider`.

عند إنشاء bloc، يمكننا الوصول إلى مثيل المستودع عبر `context.read` وحقن المستودع
في الـ bloc عبر المُنشئ (constructor).

<WeatherAppSnippet />

:::tip

إذا كان لديك أكثر من مستودع واحد، يمكنك استخدام `MultiRepositoryProvider` لتوفير
عدة مستودعات للشجرة الفرعية.

:::

:::note

استخدم `dispose` للتعامل مع تحرير الموارد عند إزالة `RepositoryProvider` من شجرة
الـ Widgets.

:::

[flutter_weather_link]:
	https://github.com/felangel/bloc/blob/master/examples/flutter_weather

## دوال الامتداد (Extension Methods)

[دوال الامتداد](https://dart.dev/guides/language/extension-methods)، التي تم
تقديمها في Dart 2.7، هي طريقة لإضافة وظائف إلى المكتبات الموجودة. في هذا القسم،
سنلقي نظرة على دوال الامتداد في `package:flutter_bloc` وكيف يمكن استخدامها.

تعتمد `flutter_bloc` على [package:provider](https://pub.dev/packages/provider)
والتي تبسط استخدام
[`InheritedWidget`](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html).

داخليًا، تستخدم `package:flutter_bloc` حزمة `provider` لتنفيذ: `BlocProvider` و
`MultiBlocProvider` و `RepositoryProvider` و `MultiRepositoryProvider`. كما تصدر
امتدادات `ReadContext` و `WatchContext` و `SelectContext` من `provider`.

:::note

تعرف على المزيد حول [`package:provider`](https://pub.dev/packages/provider).

:::

### context.read

تقوم `context.read<T>()` بالبحث عن أقرب مثيل سلف من النوع `T` وهي مكافئة وظيفيًا
لـ `BlocProvider.of<T>(context)`. تُستخدم غالبًا لاسترداد مثيل bloc لإضافة حدث
داخل `onPressed`.

:::note

`context.read<T>()` لا تستمع إلى `T` - إذا تغير الكائن المقدم من النوع `T` فلن
تؤدي `context.read` إلى إعادة بناء الـ Widget.

:::

#### الاستخدام

✅ **افعل** استخدام `context.read` لإضافة الأحداث في callbacks.

```dart
onPressed() {
  context.read<CounterBloc>().add(CounterIncrementPressed()),
}
```

❌ **تجنب** استخدام `context.read` لاسترداد الحالة داخل `build`.

```dart
@override
Widget build(BuildContext context) {
  final state = context.read<MyBloc>().state;
  return Text('$state');
}
```

الاستخدام أعلاه عرضة للخطأ لأن ويدجت `Text` لن يتم إعادة بناؤه إذا تغيرت حالة
الـ bloc.

:::caution

استخدم `BlocBuilder` أو `context.watch` بدلًا من ذلك لإعادة البناء عند تغير
الحالة.

:::

### context.watch

مثل `context.read<T>()`، توفر `context.watch<T>()` أقرب مثيل سلف من النوع `T`
لكنها تستمع أيضًا للتغييرات على المثيل. وهي مكافئة وظيفيًا لـ
`BlocProvider.of<T>(context, listen: true)`.

إذا تغير الكائن المقدم من النوع `T` فستؤدي `context.watch` إلى إعادة بناء
(rebuild).

:::caution

`context.watch` متاحة فقط داخل `build` في `StatelessWidget` أو `State`.

:::

#### الاستخدام

✅ **افعل** استخدام `BlocBuilder` بدلًا من `context.watch` لتحديد نطاق إعادة
البناء بشكل صريح.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocBuilder<MyBloc, MyState>(
        builder: (context, state) {
          // Whenever the state changes, only the Text is rebuilt.
          return Text(state.value);
        },
      ),
    ),
  );
}
```

بدلًا من ذلك، استخدم `Builder` لتحديد نطاق إعادة البناء.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Whenever the state changes, only the Text is rebuilt.
          final state = context.watch<MyBloc>().state;
          return Text(state.value);
        },
      ),
    ),
  );
}
```

✅ **افعل** استخدام `Builder` و `context.watch` كبديل لـ `MultiBlocBuilder`.

```dart
Builder(
  builder: (context) {
    final stateA = context.watch<BlocA>().state;
    final stateB = context.watch<BlocB>().state;
    final stateC = context.watch<BlocC>().state;

    // return a Widget which depends on the state of BlocA, BlocB, and BlocC
  }
);
```

❌ **تجنب** استخدام `context.watch` عندما لا يعتمد الـ Widget الأب على الحالة.

```dart
@override
Widget build(BuildContext context) {
  // Whenever the state changes, the MaterialApp is rebuilt
  // even though it is only used in the Text widget.
  final state = context.watch<MyBloc>().state;
  return MaterialApp(
    home: Scaffold(
      body: Text(state.value),
    ),
  );
}
```

:::caution

سيؤدي استخدام `context.watch` في جذر `build` إلى إعادة بناء الـ Widget بالكامل
عند تغير حالة الـ bloc.

:::

### context.select

تمامًا مثل `context.watch<T>()`، توفر `context.select<T, R>(...)` أقرب مثيل سلف
من النوع `T` وتستمع إلى التغييرات عليه، لكنها تسمح بالاستماع إلى جزء أصغر من
الحالة.

```dart
Widget build(BuildContext context) {
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return Text(name);
}
```

سيُعاد بناء الـ Widget فقط عند تغير خاصية `name` في حالة `ProfileBloc`.

#### الاستخدام

✅ **افعل** استخدام `BlocSelector` بدلًا من `context.select` لتحديد نطاق إعادة
البناء بشكل صريح.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocSelector<ProfileBloc, ProfileState, String>(
        selector: (state) => state.name,
        builder: (context, name) {
          // Whenever the state.name changes, only the Text is rebuilt.
          return Text(name);
        },
      ),
    ),
  );
}
```

بدلًا من ذلك، استخدم `Builder` لتحديد نطاق إعادة البناء.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Whenever state.name changes, only the Text is rebuilt.
          final name = context.select((ProfileBloc bloc) => bloc.state.name);
          return Text(name);
        },
      ),
    ),
  );
}
```

❌ **تجنب** استخدام `context.select` عندما لا يعتمد الـ Widget الأب على الحالة.

```dart
@override
Widget build(BuildContext context) {
  // Whenever the state.value changes, the MaterialApp is rebuilt
  // even though it is only used in the Text widget.
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return MaterialApp(
    home: Scaffold(
      body: Text(name),
    ),
  );
}
```

:::caution

سيؤدي استخدام `context.select` في جذر `build` إلى إعادة بناء الـ Widget بالكامل
عند تغير الاختيار (selection).

:::
