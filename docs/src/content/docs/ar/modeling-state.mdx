---
title: نمذجة الحالة (Modeling State)
description: نظرة عامة على عدة طرق لنمذجة الحالات عند استخدام حزمة bloc.
---

import ConcreteClassAndStatusEnumSnippet from '~/components/modeling-state/ConcreteClassAndStatusEnumSnippet.astro';
import SealedClassAndSubclassesSnippet from '~/components/modeling-state/SealedClassAndSubclassesSnippet.astro';

هناك العديد من الأساليب المختلفة عندما يتعلق الأمر بهيكلة حالة التطبيق. لكل
أسلوب مزاياه وعيوبه. في هذا القسم، سنستعرض عدة أساليب، مع إيجابياتها وسلبياتها،
ومتى يُفضّل استخدام كل منها.

الأساليب التالية هي مجرد توصيات وهي اختيارية بالكامل. لا تتردد في استخدام أي
أسلوب تفضله. قد تلاحظ أن بعض الأمثلة/التوثيقات لا تتبع هذه الأساليب بشكل صارم،
وذلك لأسباب تتعلق بالتبسيط/الإيجاز.

:::tip

تركز مقتطفات الكود التالية على هيكل الحالة. من الناحية العملية، قد ترغب أيضًا
في:

- توسيع `Equatable` من حزمة
  [`package:equatable`](https://pub.dev/packages/equatable)
- استخدام التعليق التوضيحي `@Data()` للفئة من حزمة
  [`package:data_class`](https://pub.dev/packages/data_class)
- استخدام التعليق التوضيحي `@immutable` للفئة من حزمة
  [`package:meta`](https://pub.dev/packages/meta)
- تنفيذ دالة `copyWith`
- استخدام الكلمة المفتاحية `const` للمُنشئات (constructors)

:::

## الفئة الملموسة وتعداد الحالة (Concrete Class and Status Enum)

يتكون هذا الأسلوب من **فئة ملموسة واحدة** لجميع الحالات، إلى جانب `enum` يمثل
حالات/Statuses مختلفة. يتم جعل الخصائص قابلة للقيمة الفارغة (nullable) ويتم
التعامل معها بناءً على الحالة الحالية. يعمل هذا الأسلوب بشكل أفضل للحالات التي
ليست حصرية بشكل صارم و/أو تحتوي على الكثير من الخصائص المشتركة.

<ConcreteClassAndStatusEnumSnippet />

#### الإيجابيات

- **بسيط**: سهل إدارة فئة واحدة وتعداد حالة (status enum)، وجميع الخصائص متاحة
  بسهولة.
- **موجز**: يتطلب غالبًا عددًا أقل من أسطر الكود مقارنة بالأساليب الأخرى.

#### السلبيات

- **غير آمن من حيث النوع (Not Type Safe)**: يتطلب التحقق من `status` قبل الوصول
  إلى الخصائص. من الممكن إصدار حالة غير صحيحة (`emit` a malformed state) مما قد
  يؤدي إلى أخطاء. كما أن خصائص حالات معينة تكون nullable، وقد يكون التعامل معها
  مرهقًا ويتطلب إما فك تغليف قسري (force unwrapping) أو إجراء فحوصات null. يمكن
  التخفيف من بعض هذه السلبيات عبر اختبارات الوحدة (unit tests) أو إنشاء مُنشئات
  (constructors) مخصصة ومُسماة.
- **متضخم**: ينتج عنه State واحدة قد تصبح متضخمة مع مرور الوقت بسبب كثرة
  الخصائص.

#### الحكم

يعمل هذا الأسلوب بشكل أفضل للحالات البسيطة أو عندما تتطلب المتطلبات حالات ليست
حصرية (مثل إظهار Snackbar عند حدوث خطأ مع الاستمرار في عرض البيانات القديمة من
آخر حالة نجاح). يوفر مرونة وإيجازًا على حساب أمان النوع.

## الفئة المختومة والفئات الفرعية (Sealed Class and Subclasses)

يتكون هذا الأسلوب من **فئة مختومة (sealed class)** تحتوي على الخصائص المشتركة،
مع عدة فئات فرعية تمثل الحالات المنفصلة. هذا الأسلوب مناسب جدًا للحالات المنفصلة
والحصرية.

<SealedClassAndSubclassesSnippet />

#### الإيجابيات

- **آمن من حيث النوع (Type Safe)**: الكود آمن وقت التجميع (compile-safe) ولا
  يمكن الوصول بالخطأ إلى خاصية غير صالحة. كل فئة فرعية تحتوي خصائصها الخاصة، مما
  يجعل من الواضح ما الذي ينتمي لأي حالة.
- **صريح (Explicit)**: يفصل الخصائص المشتركة عن الخصائص الخاصة بكل حالة.
- **شامل (Exhaustive)**: يمكنك استخدام `switch` لفحوصات الشمول (exhaustiveness
  checks) لضمان التعامل مع كل حالة بشكل صريح.
  - إذا كنت لا تريد
    [التبديل الشامل](https://dart.dev/language/branches#exhaustiveness-checking)
    أو تريد إضافة أنواع فرعية لاحقًا دون كسر واجهة الـ API، فاستخدم
    [final](https://dart.dev/language/class-modifiers#final).
  - راجع [توثيق sealed class](https://dart.dev/language/class-modifiers#sealed)
    لمزيد من التفاصيل.

#### السلبيات

- **مطوّل (Verbose)**: يتطلب كودًا أكثر (فئة أساسية + فئة فرعية لكل حالة). وقد
  يتطلب تكرارًا للخصائص المشتركة عبر الفئات الفرعية.
- **أكثر تعقيدًا (Complex)**: إضافة خصائص جديدة قد تتطلب تحديث الفئة الأساسية
  وجميع الفئات الفرعية، مما يزيد التعقيد. وقد يؤدي أيضًا إلى فحوصات نوع إضافية
  للوصول إلى خصائص معينة.

#### الحكم

يعمل هذا الأسلوب بشكل أفضل للحالات المحددة جيدًا والحصرية ذات الخصائص الفريدة.
يوفر أمان النوع وفحوصات الشمول، ويؤكد على السلامة أكثر من الإيجاز والبساطة.
