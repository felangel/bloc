---
title: Flutter Counter
description:
  دليل متعمّق لبناء تطبيق عدّاد (Counter) في Flutter باستخدام مكتبة Bloc.
sidebar:
  order: 1
---

import RemoteCode from '~/components/code/RemoteCode.astro';
import FlutterCreateSnippet from '~/components/tutorials/flutter-counter/FlutterCreateSnippet.astro';
import FlutterPubGetSnippet from '~/components/tutorials/FlutterPubGetSnippet.astro';

![beginner](https://img.shields.io/badge/level-beginner-green.svg)

في هذا الدليل التعليمي، سنبني تطبيق **عداد (Counter)** في Flutter باستخدام مكتبة
**Bloc**.

![demo](~/assets/tutorials/flutter-counter.gif)

## المواضيع الرئيسية (Key Topics)

- مراقبة تغييرات الحالة باستخدام
  [`BlocObserver`](/ar/bloc-concepts#blocobserver).
- [`BlocProvider`](/ar/flutter-bloc-concepts#blocprovider)، وهي Widget في
  Flutter توفّر Bloc للأبناء.
- [`BlocBuilder`](/ar/flutter-bloc-concepts#blocbuilder)، وهي Widget في Flutter
  تتولّى إعادة البناء استجابةً للحالات الجديدة.
- استخدام Cubit بدلاً من Bloc.
  [ما هو الفرق؟](/ar/bloc-concepts/#cubit-مقابل-bloc)
- إضافة الأحداث باستخدام
  [`context.read`](/ar/flutter-bloc-concepts#contextread).

## الإعداد (Setup)

سنبدأ بإنشاء مشروع Flutter جديد بالكامل:

<FlutterCreateSnippet />

بعد ذلك، يمكننا استبدال محتويات ملف `pubspec.yaml` بما يلي:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/pubspec.yaml"
	title="pubspec.yaml"
/>

ثم نثبّت جميع التبعيات (dependencies):

<FlutterPubGetSnippet />

## هيكل المشروع (Project Structure)

```
├── lib
│   ├── app.dart
│   ├── counter
│   │   ├── counter.dart
│   │   ├── cubit
│   │   │   └── counter_cubit.dart
│   │   └── view
│   │       ├── counter_page.dart
│   │       ├── counter_view.dart
│   │       └── view.dart
│   ├── counter_observer.dart
│   └── main.dart
├── pubspec.lock
├── pubspec.yaml
```

يستخدم التطبيق هيكل مجلدات يعتمد على الميزات (feature-driven directory
structure). هذا النمط يساعدنا على توسيع المشروع عبر ميزات مستقلة بذاتها. في هذا
المثال لدينا ميزة واحدة فقط (العداد نفسه)، لكن في التطبيقات الأكثر تعقيدًا قد
نمتلك مئات الميزات المختلفة.

## BlocObserver

أول ما سنراجعه هو إنشاء `BlocObserver` الذي يساعدنا على مراقبة جميع تغييرات
الحالة في التطبيق.

لننشئ الملف `lib/counter_observer.dart`:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter_observer.dart"
	title="lib/counter_observer.dart"
/>

في هذه الحالة، نقوم فقط بعمل override للدالة `onChange` لمتابعة جميع تغييرات
الحالة.

:::note

تعمل الدالة `onChange` بالطريقة نفسها في instances من `Bloc` و`Cubit`.

:::

## main.dart

بعد ذلك، استبدل محتويات الملف `lib/main.dart` بما يلي:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/main.dart"
	title="lib/main.dart"
/>

هنا نهيّئ `CounterObserver` الذي أنشأناه للتو، ثم نستدعي `runApp` باستخدام
Widget `CounterApp` التي سنراجعها الآن.

## تطبيق العداد (Counter App)

لننشئ الملف `lib/app.dart`:

`CounterApp` هو `MaterialApp` ويحدد `home` على أنه `CounterPage`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/app.dart"
	title="lib/app.dart"
/>

:::note

نقوم بعمل extend لـ `MaterialApp` لأن `CounterApp` **هو** `MaterialApp`. في أغلب
الحالات سننشئ instances من `StatelessWidget` أو `StatefulWidget` ونركّب Widgets
داخل `build`، لكن في هذا المثال لا توجد Widgets تحتاج إلى تركيب، لذا فإن extend
المباشر لـ `MaterialApp` أبسط.

:::

لننتقل الآن إلى `CounterPage`.

## صفحة العداد (Counter Page)

لننشئ الملف `lib/counter/view/counter_page.dart`:

تتولى Widget `CounterPage` إنشاء `CounterCubit` (الذي سنراجعه بعد قليل) وتوفيره
إلى `CounterView`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter/view/counter_page.dart"
	title="lib/counter/view/counter_page.dart"
/>

:::note

من المهم فصل إنشاء `Cubit` عن استهلاكه للحصول على أكواد برمجية أكثر قابلية
للاختبار وإعادة الاستخدام.

:::

## Counter Cubit

لننشئ الملف `lib/counter/cubit/counter_cubit.dart`:

تعرض class `CounterCubit` طريقتين (methods):

- `increment`: تضيف 1 إلى الحالة الحالية
- `decrement`: تطرح 1 من الحالة الحالية

نوع الحالة الذي يديره `CounterCubit` هو `int` فقط، والحالة الأولية هي `0`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter/cubit/counter_cubit.dart"
	title="lib/counter/cubit/counter_cubit.dart"
/>

:::tip

استخدم
[إضافة VSCode](https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc)
أو [Plugin لـ IntelliJ](https://plugins.jetbrains.com/plugin/12129-bloc) لإنشاء
Cubits جديدة تلقائيًا.

:::

بعد ذلك، لنراجع `CounterView`، وهي المسؤولة عن استهلاك الحالة والتفاعل مع
`CounterCubit`.

## عرض العداد (Counter View)

لننشئ الملف `lib/counter/view/counter_view.dart`:

`CounterView` مسؤولة عن عرض قيمة العداد الحالية، وإظهار زري
`FloatingActionButton` لزيادة/إنقاص العداد.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter/view/counter_view.dart"
	title="lib/counter/view/counter_view.dart"
/>

نستخدم `BlocBuilder` لتغليف Widget `Text` بهدف تحديث النص كلما تغيّرت حالة
`CounterCubit`. بالإضافة إلى ذلك، نستخدم `context.read<CounterCubit>()` للعثور
على أقرب instance من `CounterCubit`.

:::note

تم تغليف Widget `Text` فقط داخل `BlocBuilder` لأنها الوحيدة التي تحتاج إعادة
بناء عند تغيّر حالة `CounterCubit`. تجنّب تغليف Widgets لا تحتاج لإعادة البناء
عند تغيّر الحالة.

:::

## Barrel (تجميع الصادرات)

لننشئ الملف `lib/counter/view/view.dart`:

أضف `view.dart` لتصدير جميع الأجزاء العامة (public) الخاصة بعرض العداد.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter/view/view.dart"
	title="lib/counter/view/view.dart"
/>

لننشئ الملف `lib/counter/counter.dart`:

أضف `counter.dart` لتصدير جميع الأجزاء العامة (public) الخاصة بميزة العداد.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_counter/lib/counter/counter.dart"
	title="lib/counter/counter.dart"
/>

انتهينا! قمنا بفصل طبقة العرض (presentation layer) عن طبقة منطق الأعمال
(business logic layer). لا تعرف `CounterView` ماذا يحدث عند ضغط المستخدم على
الزر؛ هي فقط تُخطر `CounterCubit`. وفي المقابل، لا يعرف `CounterCubit` شيئًا عن
طريقة عرض الحالة (قيمة العداد)، بل يصدر حالات جديدة استجابةً لاستدعاء methods.

يمكننا تشغيل التطبيق بالأمر `flutter run` وعرضه على الجهاز أو
simulator/emulator.

يمكن العثور على المصدر الكامل (بما في ذلك اختبارات الوحدة واختبارات Widgets)
لهذا المثال
[هنا](https://github.com/felangel/Bloc/tree/master/examples/flutter_counter).
