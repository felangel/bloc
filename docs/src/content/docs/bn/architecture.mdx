---
title: আর্কিটেকচার
description: Bloc ব্যবহার করার সময় সুপারিশকৃত আর্কিটেকচার প্যাটার্নগুলোর একটি ওভারভিউ।
---

import DataProviderSnippet from '~/components/architecture/DataProviderSnippet.astro';
import RepositorySnippet from '~/components/architecture/RepositorySnippet.astro';
import BusinessLogicComponentSnippet from '~/components/architecture/BusinessLogicComponentSnippet.astro';
import BlocTightCouplingSnippet from '~/components/architecture/BlocTightCouplingSnippet.astro';
import BlocLooseCouplingPresentationSnippet from '~/components/architecture/BlocLooseCouplingPresentationSnippet.astro';
import AppIdeasRepositorySnippet from '~/components/architecture/AppIdeasRepositorySnippet.astro';
import AppIdeaRankingBlocSnippet from '~/components/architecture/AppIdeaRankingBlocSnippet.astro';
import PresentationComponentSnippet from '~/components/architecture/PresentationComponentSnippet.astro';

![Bloc Architecture](~/assets/concepts/bloc_architecture_full.png)

Bloc লাইব্রেরি ব্যবহার করলে আমরা আমাদের অ্যাপ্লিকেশনকে তিনটি স্তরে ভাগ করতে পারি:

- প্রেজেন্টেশন
- বিজনেস লজিক
- ডেটা
  - রিপোজিটরি
  - ডেটা প্রোভাইডার

আমরা ব্যবহারকারীর ইন্টারফেস থেকে সবচেয়ে দূরের (সবচেয়ে নিচের) স্তর থেকে শুরু করব এবং প্রেজেন্টেশন লেয়ার পর্যন্ত উপরের দিকে এগোব।

## ডেটা লেয়ার

ডেটা লেয়ারের দায়িত্ব হলো এক বা একাধিক সোর্স থেকে ডেটা উদ্ধার/ম্যানিপুলেট করা।

ডেটা লেয়ার দুইটি অংশে বিভক্ত হতে পারে:

- রিপোজিটরি
- ডেটা প্রোভাইডার

এই লেয়ারটি অ্যাপ্লিকেশনের সবচেয়ে নিচের স্তর এবং এটি ডাটাবেস, নেটওয়ার্ক রিকোয়েস্ট এবং অন্যান্য অ্যাসিঙ্ক্রোনাস ডেটা সোর্সের সাথে ইন্টারঅ্যাক্ট করে।

### ডেটা প্রোভাইডার

ডেটা প্রোভাইডারের দায়িত্ব হলো র’ ডেটা সরবরাহ করা। ডেটা প্রোভাইডারটি জেনেরিক এবং বহুমুখী হওয়া উচিত।

ডেটা প্রোভাইডার সাধারণত [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) অপারেশন সম্পাদনের জন্য সরল API প্রদান করবে। উদাহরণস্বরূপ, আমাদের `createData`, `readData`, `updateData`, এবং `deleteData` মেথড থাকতে পারে।

<DataProviderSnippet />

### রিপোজিটরি

রিপোজিটরি লেয়ার হলো এক বা একাধিক ডেটা প্রোভাইডারের একটি র‍্যাপার, যার সাথে Bloc লেয়ার যোগাযোগ করে।

<RepositorySnippet />

যেমনটি দেখানো হয়েছে, আমাদের রিপোজিটরি লেয়ার একাধিক ডেটা প্রোভাইডারের সাথে ইন্টারঅ্যাক্ট করতে পারে এবং বিজনেস লজিক লেয়ারকে ফলাফল দেওয়ার আগে ডেটা ট্রান্সফর্ম করতে পারে।

## বিজনেস লজিক লেয়ার

বিজনেস লজিক লেয়ারের দায়িত্ব হলো প্রেজেন্টেশন লেয়ার থেকে ইনপুট নিয়ে নতুন স্টেট তৈরি করা। এই লেয়ার এক বা একাধিক রিপোজিটরির উপর নির্ভর করতে পারে প্রয়োজনীয় ডেটা উদ্ধারের জন্য।

বিজনেস লজিক লেয়ারকে প্রেজেন্টেশন লেয়ার এবং ডেটা লেয়ারের মধ্যে একটি ব্রিজ হিসেবে ভাবুন। এটি প্রেজেন্টেশন লেয়ার থেকে ইভেন্ট/অ্যাকশন নোটিফাই হয় এবং নতুন স্টেট তৈরি করতে রিপোজিটরির সাথে যোগাযোগ করে যা প্রেজেন্টেশন লেয়ার ব্যবহার করবে।

<BusinessLogicComponentSnippet />

### Bloc-to-Bloc কমিউনিকেশন

কারণ ব্লকগুলি স্ট্রিম প্রকাশ করে, তাই একটি ব্লক অন্য ব্লককে লিসেন করে তৈরি করা প্রলোভন হতে পারে। তবে এটি **করবেন না**। নিচের কোডের চেয়ে ভালো বিকল্প রয়েছে:

<BlocTightCouplingSnippet />

উপরের কোডটি ত্রুটিমুক্ত হলেও, এতে একটি বড় সমস্যা রয়েছে: এটি দুইটি ব্লকের মধ্যে নির্ভরতা তৈরি করে।

সাধারণভাবে, একই আর্কিটেকচার স্তরের দুটি সিবলিং এন্টিটির মধ্যে নির্ভরতা এড়ানো উচিত, কারণ এটি কঠিন এবং রক্ষণাবেক্ষণে অসুবিধাজনক। যেহেতু ব্লকগুলি বিজনেস লজিক আর্কিটেকচার লেয়ারে থাকে, কোন ব্লকই অন্য ব্লকের সম্পর্কে জানবে না।

একটি ব্লককে অন্য ব্লকের পরিবর্তনের উপর রেসপন্ড করতে হলে, আপনার দুটি বিকল্প রয়েছে। আপনি সমস্যা উপরের স্তরে (প্রেজেন্টেশন লেয়ারে) বা নিচের স্তরে (ডোমেইন লেয়ারে) ঠেলতে পারেন।

#### প্রেজেন্টেশন লেয়ারের মাধ্যমে ব্লক সংযোগ

`BlocListener` ব্যবহার করে একটি ব্লককে লিসেন করতে এবং প্রথম ব্লক পরিবর্তিত হলে অন্য ব্লকে ইভেন্ট যোগ করতে পারেন।

<BlocLooseCouplingPresentationSnippet />

উপরের কোডটি `SecondBloc`-কে `FirstBloc` সম্পর্কে জানার প্রয়োজন থেকে মুক্ত রাখে, এবং লুজ-কাপলিংকে উৎসাহিত করে। [flutter_weather](/tutorials/flutter-weather) অ্যাপ্লিকেশনটি
এই কৌশল ব্যবহার করে [এখানে](https://github.com/felangel/bloc/blob/b4c8db938ad71a6b60d4a641ec357905095c3965/examples/flutter_weather/lib/weather/view/weather_page.dart#L38-L42)
আবহাওয়ার উপর ভিত্তি করে অ্যাপের থিম পরিবর্তন করে।

কিছু পরিস্থিতিতে, প্রেজেন্টেশন লেয়ারে দুইটি ব্লক কাপল করতে চাইতে নাও পারেন। বরং, দুটি ব্লক একই ডেটা সোর্স ভাগ করতে পারে এবং ডেটা পরিবর্তনের সাথে সাথে স্টেট আপডেট করতে পারে।

#### ডোমেইন লেয়ারের মাধ্যমে ব্লক সংযোগ

দুটি ব্লক রিপোজিটরির স্ট্রিম শুনতে পারে এবং রিপোজিটরি ডেটা পরিবর্তিত হলে স্বাধীনভাবে তাদের স্টেট আপডেট করে। বড় স্কেলের এন্টারপ্রাইজ অ্যাপ্লিকেশনে স্টেট সিঙ্ক্রোনাইজ করার জন্য রিয়েক্টিভ রিপোজিটরি ব্যবহার করা সাধারণ।

প্রথমে একটি রিপোজিটরি তৈরি করুন বা ব্যবহার করুন যা একটি ডেটা `Stream` প্রদান করে। উদাহরণস্বরূপ, নিচের রিপোজিটরিটি কিছু অ্যাপ আইডিয়ার একটি অবিরাম স্ট্রিম প্রকাশ করে:

<AppIdeasRepositorySnippet />

একই রিপোজিটরিটি প্রতিটি ব্লকে ইঞ্জেক্ট করা যেতে পারে যা নতুন অ্যাপ আইডিয়ার জন্য রেসপন্ড করতে চায়। নিচে একটি `AppIdeaRankingBloc` দেখানো হলো যা রিপোজিটরি থেকে প্রতিটি আসা আইডিয়ার জন্য স্টেট প্রকাশ করে:

<AppIdeaRankingBlocSnippet />

ব্লকের স্ট্রিম এবং কনকারেন্সি ব্যবহার করার বিষয়ে আরও জানার জন্য দেখুন [How to use Bloc with streams and concurrency](https://verygood.ventures/blog/how-to-use-bloc-with-streams-and-concurrency)।

## প্রেজেন্টেশন লেয়ার

প্রেজেন্টেশন লেয়ারের দায়িত্ব হলো এক বা একাধিক ব্লক স্টেটের উপর ভিত্তি করে নিজেকে রেন্ডার করা। এছাড়াও এটি ইউজার ইনপুট এবং অ্যাপ্লিকেশন লাইফসাইকেল ইভেন্ট হ্যান্ডেল করে।

অধিকাংশ অ্যাপ্লিকেশন ফ্লো শুরু হয় একটি `AppStart` ইভেন্ট দিয়ে, যা ব্যবহারকারীর জন্য প্রদর্শনের জন্য কিছু ডেটা ফেচ করতে ট্রিগার করে।

এই পরিস্থিতিতে, প্রেজেন্টেশন লেয়ার `AppStart` ইভেন্ট যোগ করবে।

এছাড়াও, প্রেজেন্টেশন লেয়ারকে ব্লক লেয়ারের স্টেট অনুযায়ী স্ক্রিনে কী রেন্ডার করতে হবে তা নির্ধারণ করতে হবে।

<PresentationComponentSnippet />

এখন পর্যন্ত, যদিও কিছু কোড স্নিপেট দেখানো হয়েছে, সবকিছু এখনও উচ্চ-স্তরের। টিউটোরিয়াল সেকশনে আমরা একাধিক উদাহরণ অ্যাপ বানিয়ে সবকিছু একত্রে দেখাবো।
