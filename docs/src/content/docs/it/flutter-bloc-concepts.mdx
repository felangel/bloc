---
title: Concetti Flutter Bloc
description: Una panoramica dei concetti fondamentali per package:flutter_bloc.
sidebar:
  order: 2
---

import BlocBuilderSnippet from '~/components/concepts/flutter-bloc/BlocBuilderSnippet.astro';
import BlocBuilderExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocBuilderExplicitBlocSnippet.astro';
import BlocBuilderConditionSnippet from '~/components/concepts/flutter-bloc/BlocBuilderConditionSnippet.astro';
import BlocSelectorSnippet from '~/components/concepts/flutter-bloc/BlocSelectorSnippet.astro';
import BlocProviderSnippet from '~/components/concepts/flutter-bloc/BlocProviderSnippet.astro';
import BlocProviderEagerSnippet from '~/components/concepts/flutter-bloc/BlocProviderEagerSnippet.astro';
import BlocProviderValueSnippet from '~/components/concepts/flutter-bloc/BlocProviderValueSnippet.astro';
import BlocProviderLookupSnippet from '~/components/concepts/flutter-bloc/BlocProviderLookupSnippet.astro';
import NestedBlocProviderSnippet from '~/components/concepts/flutter-bloc/NestedBlocProviderSnippet.astro';
import MultiBlocProviderSnippet from '~/components/concepts/flutter-bloc/MultiBlocProviderSnippet.astro';
import BlocListenerSnippet from '~/components/concepts/flutter-bloc/BlocListenerSnippet.astro';
import BlocListenerExplicitBlocSnippet from '~/components/concepts/flutter-bloc/BlocListenerExplicitBlocSnippet.astro';
import BlocListenerConditionSnippet from '~/components/concepts/flutter-bloc/BlocListenerConditionSnippet.astro';
import NestedBlocListenerSnippet from '~/components/concepts/flutter-bloc/NestedBlocListenerSnippet.astro';
import MultiBlocListenerSnippet from '~/components/concepts/flutter-bloc/MultiBlocListenerSnippet.astro';
import BlocConsumerSnippet from '~/components/concepts/flutter-bloc/BlocConsumerSnippet.astro';
import BlocConsumerConditionSnippet from '~/components/concepts/flutter-bloc/BlocConsumerConditionSnippet.astro';
import RepositoryProviderSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderSnippet.astro';
import RepositoryProviderLookupSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderLookupSnippet.astro';
import RepositoryProviderDisposeSnippet from '~/components/concepts/flutter-bloc/RepositoryProviderDisposeSnippet.astro';
import NestedRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/NestedRepositoryProviderSnippet.astro';
import MultiRepositoryProviderSnippet from '~/components/concepts/flutter-bloc/MultiRepositoryProviderSnippet.astro';
import CounterBlocSnippet from '~/components/concepts/flutter-bloc/CounterBlocSnippet.astro';
import CounterMainSnippet from '~/components/concepts/flutter-bloc/CounterMainSnippet.astro';
import CounterPageSnippet from '~/components/concepts/flutter-bloc/CounterPageSnippet.astro';
import WeatherRepositorySnippet from '~/components/concepts/flutter-bloc/WeatherRepositorySnippet.astro';
import WeatherMainSnippet from '~/components/concepts/flutter-bloc/WeatherMainSnippet.astro';
import WeatherAppSnippet from '~/components/concepts/flutter-bloc/WeatherAppSnippet.astro';
import WeatherPageSnippet from '~/components/concepts/flutter-bloc/WeatherPageSnippet.astro';

:::note

Assicurati di leggere attentamente le seguenti sezioni prima di lavorare con
[`package:flutter_bloc`](https://pub.dev/packages/flutter_bloc).

:::

:::note

Tutti i widget esportati dal pacchetto `flutter_bloc` si integrano con entrambe le istanze `Cubit`
e `Bloc`.

:::

## Widget Bloc

### BlocBuilder

**BlocBuilder** è un widget Flutter che richiede un `Bloc` e una funzione
`builder`. `BlocBuilder` gestisce la costruzione del widget in risposta a nuovi stati.
`BlocBuilder` è molto simile a `StreamBuilder` ma ha un'API più semplice per
ridurre la quantità di codice boilerplate necessario. La funzione `builder` sarà
potenzialmente chiamata molte volte e dovrebbe essere una
[funzione pura](https://en.wikipedia.org/wiki/Pure_function) che restituisce un
widget in risposta allo stato.

Vedi `BlocListener` se vuoi "fare" qualcosa in risposta ai cambiamenti di stato
come navigazione, mostrare un dialog, ecc...

Se il parametro `bloc` è omesso, `BlocBuilder` eseguirà automaticamente una
ricerca usando `BlocProvider` e il `BuildContext` corrente.

<BlocBuilderSnippet />

Specifica il bloc solo se desideri fornire un bloc che sarà limitato a un
singolo widget e non è accessibile tramite un `BlocProvider` padre e il
`BuildContext` corrente.

<BlocBuilderExplicitBlocSnippet />

Per un controllo granulare su quando la funzione `builder` viene chiamata può essere fornit opzionalmente un
`buildWhen`. `buildWhen` prende lo stato precedente e quello corrente del bloc e restituisce un booleano. Se `buildWhen` restituisce `true`, `builder`
sarà chiamato con `state` e il widget si ricostruirà. Se `buildWhen` restituisce
`false`, `builder` non sarà chiamato con `state` e non si verificherà alcun aggiornamento.

<BlocBuilderConditionSnippet />

### BlocSelector

**BlocSelector** è un widget Flutter che è analogo a `BlocBuilder` ma
permette agli sviluppatori di filtrare gli aggiornamenti selezionando un nuovo valore in base allo
stato corrente del bloc. Gli aggiornamenti non necessari sono prevenuti se il valore selezionato non
cambia. Il valore selezionato deve essere immutabile affinché `BlocSelector` possa
determinare accuratamente se `builder` dovrebbe essere chiamato di nuovo.

Se il parametro `bloc` è omesso, `BlocSelector` eseguirà automaticamente una
ricerca usando `BlocProvider` e il `BuildContext` corrente.

<BlocSelectorSnippet />

### BlocProvider

**BlocProvider** è un widget Flutter che fornisce un bloc ai suoi figli tramite
`BlocProvider.of<T>(context)`. È usato come widget di dependency injection (DI)
così che una singola istanza di un bloc possa essere fornita a più widget all'interno di un
sottoalbero.

Nella maggior parte dei casi, `BlocProvider` dovrebbe essere usato per creare nuovi bloc che saranno
resi disponibili al resto del sottoalbero. In questo caso, poiché `BlocProvider` è
responsabile della creazione del bloc, gestirà automaticamente la chiusura del
bloc.

<BlocProviderSnippet />

Di default, `BlocProvider` creerà il bloc in modo pigro (`lazy`), il che significa che `create` sarà
eseguito quando il bloc viene cercato tramite `BlocProvider.of<BlocA>(context)`.

Per sovrascrivere questo comportamento e forzare `create` ad essere eseguito immediatamente, `lazy` può
essere impostato a `false`.

<BlocProviderEagerSnippet />

In alcuni casi, `BlocProvider` può essere usato per fornire un bloc esistente a una nuova
porzione dell'albero dei widget. Questo sarà più comunemente usato quando un bloc esistente
deve essere reso disponibile a una nuova route. In questo caso, `BlocProvider`
non chiuderà automaticamente il bloc poiché non l'ha creato.

<BlocProviderValueSnippet />

poi da `ChildA`, o `ScreenA` possiamo recuperare `BlocA` con:

<BlocProviderLookupSnippet />

### MultiBlocProvider

**MultiBlocProvider** è un widget Flutter che unisce più widget `BlocProvider`
in uno unico. `MultiBlocProvider` migliora la leggibilità ed elimina
la necessità di annidare più `BlocProvider`. Usando `MultiBlocProvider` possiamo
passare da:

<NestedBlocProviderSnippet />

a:

<MultiBlocProviderSnippet />

:::caution

Quando un `BlocProvider` è definito nel contesto di un `MultiBlocProvider`,
qualsiasi `child` sarà ignorato.

:::

### BlocListener

**BlocListener** è un widget Flutter che prende un `BlocWidgetListener` e opzionalmente un
`Bloc` e invoca il `listener` in risposta ai cambiamenti di stato nel
bloc. Dovrebbe essere usato per funzionalità che devono verificarsi una volta per cambiamento di stato
come navigazione, mostrare uno `SnackBar`, mostrare un `Dialog`, ecc...

`listener` è chiamato solo una volta per ogni cambiamento di stato (**NON** è chiamato con lo
stato iniziale) ed è una funzione `void` a differenza di `builder` in `BlocBuilder`.

Se il parametro `bloc` è omesso, `BlocListener` eseguirà automaticamente una
ricerca usando `BlocProvider` e il `BuildContext` corrente.

<BlocListenerSnippet />

Specifica il bloc solo se desideri fornire un bloc che altrimenti non è
accessibile tramite `BlocProvider` e il `BuildContext` corrente.

<BlocListenerExplicitBlocSnippet />

Per un controllo granulare su quando la funzione `listener` viene chiamata può essere fornito opzionalmente un
`listenWhen`. `listenWhen` prende lo stato precedente e quello corrente del bloc e restituisce un booleano. Se `listenWhen` restituisce `true`,
`listener` sarà chiamato con `state`. Se `listenWhen` restituisce `false`,
`listener` non sarà chiamato con `state`.

<BlocListenerConditionSnippet />

### MultiBlocListener

**MultiBlocListener** è un widget Flutter che unisce più widget `BlocListener`
in uno. `MultiBlocListener` migliora la leggibilità ed elimina
la necessità di annidare più `BlocListener`. Usando `MultiBlocListener` possiamo
passare da:

<NestedBlocListenerSnippet />

a:

<MultiBlocListenerSnippet />

:::caution

Quando un `BlocListener` è definito nel contesto di un `MultiBlocListener`,
qualsiasi `child` sarà ignorato.

:::

### BlocConsumer

**BlocConsumer** espone un `builder` e un `listener` per reagire a nuovi
stati. `BlocConsumer` è analogo a un `BlocListener` e `BlocBuilder` annidati
ma riduce la quantità di boilerplate necessario. `BlocConsumer` dovrebbe essere usato solo
quando è necessario sia ricostruire la UI che eseguire altre reazioni ai cambiamenti di stato
nel `bloc`. `BlocConsumer` richiede un `BlocWidgetBuilder` e un
`BlocWidgetListener`, opzionalmente prende un `bloc`, un `BlocBuilderCondition` e un
`BlocListenerCondition`.

Se il parametro `bloc` è omesso, `BlocConsumer` eseguirà automaticamente una
ricerca usando `BlocProvider` e il `BuildContext` corrente.

<BlocConsumerSnippet />

Un `listenWhen` e `buildWhen` opzionali possono essere implementati per un controllo più granulare
su quando `listener` e `builder` sono chiamati. `listenWhen` e
`buildWhen` saranno invocati su ogni cambiamento di `state` del `bloc`. Prendono ciascuno lo
`state` precedente e lo `state` corrente e devono restituire un `bool` che determina
se la funzione `builder` e/o `listener` sarà invocata. Lo
`state` precedente sarà inizializzato allo `state` del `bloc` quando il
`BlocConsumer` è inizializzato. `listenWhen` e `buildWhen` sono opzionali e se
non sono implementati, avranno default a `true`.

<BlocConsumerConditionSnippet />

### RepositoryProvider

**RepositoryProvider** è un widget Flutter che fornisce un repository ai suoi
figli tramite `RepositoryProvider.of<T>(context)`. È usato come widget di
dependency injection (DI) così che una singola istanza di un repository possa essere fornita
a più widget all'interno di un sottoalbero. `BlocProvider` dovrebbe essere usato per fornire
bloc mentre `RepositoryProvider` dovrebbe essere usato solo per repository.

<RepositoryProviderSnippet />

poi da `ChildA` possiamo recuperare l'istanza del `Repository` con:

<RepositoryProviderLookupSnippet />

I repository che gestiscono risorse che devono essere eliminate possono farlo tramite la
callback `dispose`:

<RepositoryProviderDisposeSnippet />

### MultiRepositoryProvider

**MultiRepositoryProvider** è un widget Flutter che unisce più
widget `RepositoryProvider` in uno. `MultiRepositoryProvider` migliora la
leggibilità ed elimina la necessità di annidare più `RepositoryProvider`. Usando
`MultiRepositoryProvider` possiamo passare da:

<NestedRepositoryProviderSnippet />

a:

<MultiRepositoryProviderSnippet />

:::caution

Quando un `RepositoryProvider` è definito nel contesto di un
`MultiRepositoryProvider`, qualsiasi `child` sarà ignorato.

:::

## Uso di BlocProvider

Diamo un'occhiata a come usare `BlocProvider` per fornire un `CounterBloc` a una
`CounterPage` e reagire ai cambiamenti di stato con `BlocBuilder`.

<CounterBlocSnippet />

<CounterMainSnippet />

<CounterPageSnippet />

A questo punto abbiamo separato con successo il nostro livello di presentazione dal nostro
livello di logica applicativa. Nota che il widget `CounterPage` non sa nulla di
cosa succede quando un utente tocca i pulsanti. Il widget semplicemente dice al
`CounterBloc` che l'utente ha premuto il pulsante di incremento o decremento.

## Uso di RepositoryProvider

Daremo un'occhiata a come usare `RepositoryProvider` nel
contesto dell'esempio [`flutter_weather`][flutter_weather_link].

<WeatherRepositorySnippet />

Nel nostro `main.dart`, chiamiamo `runApp` con il nostro widget `WeatherApp`.

<WeatherMainSnippet />

Inietteremo la nostra istanza di `WeatherRepository` nel nostro albero dei widget tramite
`RepositoryProvider`.

Quando istanziamo un bloc, possiamo accedere all'istanza di un repository tramite
`context.read` e iniettare il repository nel bloc tramite costruttore.

<WeatherAppSnippet />

:::tip

Se hai più di un repository, puoi usare `MultiRepositoryProvider` per
fornire più istanze di repository al sottoalbero.

:::

:::note

Usa la callback `dispose` per gestire l'eliminazione di qualsiasi risorsa quando il
`RepositoryProvider` viene smontato.

:::

[flutter_weather_link]:
	https://github.com/felangel/bloc/blob/master/examples/flutter_weather

## Extension methods

Gli ["extension methods"](https://dart.dev/guides/language/extension-methods),
introdotti in Dart 2.7, sono un modo per aggiungere funzionalità a librerie esistenti. In
questa sezione, daremo un'occhiata alle estensione incluse in
`package:flutter_bloc` e a come possono essere usate.

`flutter_bloc` ha una dipendenza versp
[package:provider](https://pub.dev/packages/provider) che semplifica l'uso
di
[`InheritedWidget`](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html).

Internamente, `package:flutter_bloc` usa `package:provider` per implementare:
`BlocProvider`, `MultiBlocProvider`, `RepositoryProvider` e
widget `MultiRepositoryProvider`. `package:flutter_bloc` esporta le
estensioni `ReadContext`, `WatchContext` e `SelectContext` da
`package:provider`.

:::note

Scopri di più su [`package:provider`](https://pub.dev/packages/provider).

:::

### context.read

`context.read<T>()` cerca l'istanza dell'antenato più vicina di tipo `T` ed è
funzionalmente equivalente a `BlocProvider.of<T>(context)`. `context.read` è più
comunemente usato per recuperare un'istanza di bloc per aggiungere un evento all'interno di una
callback `onPressed`.

:::note

`context.read<T>()` non ascolta `T` -- se l'oggetto fornito di tipo
`T` cambia, `context.read` non attiverà un aggiornamento del widget.

:::

#### Uso

✅ **FARE** usa `context.read` per aggiungere eventi nelle callback.

```dart
onPressed() {
  context.read<CounterBloc>().add(CounterIncrementPressed()),
}
```

❌ **EVITARE** di usare `context.read` per recuperare lo stato all'interno di un metodo `build`.

```dart
@override
Widget build(BuildContext context) {
  final state = context.read<MyBloc>().state;
  return Text('$state');
}
```

L'uso sopra è soggetto a errori perché il widget `Text` non sarà ricostruito se
lo stato del bloc cambia.

:::caution

Usa invece `BlocBuilder` o `context.watch` per ricostruire la UI in risposta ai
cambiamenti di stato.

:::

### context.watch

Come `context.read<T>()`, `context.watch<T>()` fornisce l'istanza dell'antenato più vicina
di tipo `T`, tuttavia ascolta anche i cambiamenti sull'istanza. È
funzionalmente equivalente a `BlocProvider.of<T>(context, listen: true)`.

Se l'oggetto fornito di tipo `T` cambia, `context.watch` attiverà un
aggiornamento.

:::caution

`context.watch` è accessibile solo all'interno del metodo `build` di un
`StatelessWidget` o classe `State`.

:::

#### Uso

✅ **FARE** usa `BlocBuilder` invece di `context.watch` per limitare esplicitamente gli aggiornamenti.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocBuilder<MyBloc, MyState>(
        builder: (context, state) {
          // Ogni volta che lo stato cambia, solo il Text viene ricostruito.
          return Text(state.value);
        },
      ),
    ),
  );
}
```

In alternativa, usa un `Builder` per limitare gli aggiornamenti.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Ogni volta che lo stato cambia, solo il Text viene ricostruito.
          final state = context.watch<MyBloc>().state;
          return Text(state.value);
        },
      ),
    ),
  );
}
```

✅ **FARE** usa `Builder` e `context.watch` come `MultiBlocBuilder`.

```dart
Builder(
  builder: (context) {
    final stateA = context.watch<BlocA>().state;
    final stateB = context.watch<BlocB>().state;
    final stateC = context.watch<BlocC>().state;

    // restituisci un Widget che dipende dallo stato di BlocA, BlocB e BlocC
  }
);
```

❌ **EVITARE** di usare `context.watch` quando il widget padre nel metodo `build`
non dipende dallo stato.

```dart
@override
Widget build(BuildContext context) {
  // Ogni volta che lo stato cambia, la MaterialApp viene ricostruit  a
  // anche se è usato solo nel widget Text.
  final state = context.watch<MyBloc>().state;
  return MaterialApp(
    home: Scaffold(
      body: Text(state.value),
    ),
  );
}
```

:::caution

Usare `context.watch` alla radice del metodo `build` risulterà nel
aggiornamento dell'intero widget quando lo stato del bloc cambia.

:::

### context.select

Proprio come `context.watch<T>()`, `context.select<T, R>(R function(T value))`
fornisce l'istanza dell'antenato più vicina di tipo `T` e ascolta i cambiamenti su
`T`. A differenza di `context.watch`, `context.select` ti permette di ascoltare i cambiamenti in una
parte più piccola di uno stato.

```dart
Widget build(BuildContext context) {
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return Text(name);
}
```

Il codice sopra ricostruirà il widget solo quando la proprietà `name` dello
stato del `ProfileBloc` cambia.

#### Uso

✅ **FARE** usa `BlocSelector` invece di `context.select` per limitare esplicitamente gli aggiornamenti.

```dart
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: BlocSelector<ProfileBloc, ProfileState, String>(
        selector: (state) => state.name,
        builder: (context, name) {
          // Ogni volta che state.name cambia, solo il Text viene ricostruito.
          return Text(name);
        },
      ),
    ),
  );
}
```

In alternativa, usa un `Builder` per limitare gli aggiornamenti.

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    home: Scaffold(
      body: Builder(
        builder: (context) {
          // Ogni volta che state.name cambia, solo il Text viene ricostruito.
          final name = context.select((ProfileBloc bloc) => bloc.state.name);
          return Text(name);
        },
      ),
    ),
  );
}
```

❌ **EVITARE** di usare `context.select` quando il widget padre in un metodo build
non dipende dallo stato.

```dart
@override
Widget build(BuildContext context) {
  // Ogni volta che state.value cambia, il MaterialApp viene ricostruito
  // anche se è usato solo nel widget Text.
  final name = context.select((ProfileBloc bloc) => bloc.state.name);
  return MaterialApp(
    home: Scaffold(
      body: Text(name),
    ),
  );
}
```

:::caution

Usare `context.select` alla radice del metodo `build` risulterà nel
aggiornamento dell'intero widget quando la selezione cambia.

:::
