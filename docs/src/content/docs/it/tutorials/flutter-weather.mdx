---
title: Flutter Weather
description:
  Una guida approfondita su come costruire un'app Flutter weather con bloc.
sidebar:
  order: 5
---

import RemoteCode from '~/components/code/RemoteCode.astro';
import FlutterCreateSnippet from '~/components/tutorials/flutter-weather/FlutterCreateSnippet.astro';
import FeatureTreeSnippet from '~/components/tutorials/flutter-weather/FeatureTreeSnippet.astro';
import FlutterCreateApiClientSnippet from '~/components/tutorials/flutter-weather/FlutterCreateApiClientSnippet.astro';
import OpenMeteoModelsTreeSnippet from '~/components/tutorials/flutter-weather/OpenMeteoModelsTreeSnippet.astro';
import LocationJsonSnippet from '~/components/tutorials/flutter-weather/LocationJsonSnippet.astro';
import LocationDartSnippet from '~/components/tutorials/flutter-weather/LocationDartSnippet.astro';
import WeatherJsonSnippet from '~/components/tutorials/flutter-weather/WeatherJsonSnippet.astro';
import WeatherDartSnippet from '~/components/tutorials/flutter-weather/WeatherDartSnippet.astro';
import OpenMeteoModelsBarrelTreeSnippet from '~/components/tutorials/flutter-weather/OpenMeteoModelsBarrelTreeSnippet.astro';
import OpenMeteoLibrarySnippet from '~/components/tutorials/flutter-weather/OpenMeteoLibrarySnippet.astro';
import BuildRunnerBuildSnippet from '~/components/tutorials/flutter-weather/BuildRunnerBuildSnippet.astro';
import OpenMeteoApiClientTreeSnippet from '~/components/tutorials/flutter-weather/OpenMeteoApiClientTreeSnippet.astro';
import LocationSearchMethodSnippet from '~/components/tutorials/flutter-weather/LocationSearchMethodSnippet.astro';
import GetWeatherMethodSnippet from '~/components/tutorials/flutter-weather/GetWeatherMethodSnippet.astro';
import FlutterTestCoverageSnippet from '~/components/tutorials/flutter-weather/FlutterTestCoverageSnippet.astro';
import FlutterCreateRepositorySnippet from '~/components/tutorials/flutter-weather/FlutterCreateRepositorySnippet.astro';
import RepositoryModelsBarrelTreeSnippet from '~/components/tutorials/flutter-weather/RepositoryModelsBarrelTreeSnippet.astro';
import WeatherRepositoryLibrarySnippet from '~/components/tutorials/flutter-weather/WeatherRepositoryLibrarySnippet.astro';
import WeatherCubitTreeSnippet from '~/components/tutorials/flutter-weather/WeatherCubitTreeSnippet.astro';
import WeatherBarrelDartSnippet from '~/components/tutorials/flutter-weather/WeatherBarrelDartSnippet.astro';

![advanced](https://img.shields.io/badge/level-advanced-red.svg)

In questo tutorial, costruiremo un'app per vedere le previsioni meteo in Flutter
che dimostra come gestire pi√π cubit per implementare temi dinamici,
pull-to-refresh e molto altro. L'app meteo recuperer√† dati meteo in tempo reale
dall' API pubblica OpenMeteo e dimostrer√† come separare l'applicazione in
livelli (dati, repository, logica applicativa e presentazione).

![demo](~/assets/tutorials/flutter-weather.gif)

## Requisiti del Progetto

L'app dovrebbe permettere agli utenti di

- Cercare una citt√† su una pagina di ricerca dedicata;
- Vedere una piacevole rappresentazione dei dati meteo restituiti da
  [Open Meteo API](https://open-meteo.com);
- Cambiare le unit√† visualizzate (metriche vs imperiali).

Inoltre,

- Il tema dell'applicazione dovrebbe riflettere il meteo per la citt√† scelta;
- Lo stato dell'applicazione dovrebbe persistere tra le sessioni: cio√®, l'app
  dovrebbe ricordare il suo stato dopo la chiusura e la riapertura (usando
  [HydratedBloc](https://github.com/felangel/bloc/tree/master/packages/hydrated_bloc)).

## Concetti Chiave

- Osservare i cambiamenti di stato con
  [BlocObserver](/it/bloc-concepts#blocobserver);
- [BlocProvider](/it/flutter-bloc-concepts#blocprovider), widget Flutter che
  fornisce un bloc ai suoi figli;
- [BlocBuilder](/it/flutter-bloc-concepts#blocbuilder), widget Flutter che
  gestisce la costruzione del widget in risposta a nuovi stati;
- Prevenire aggiornamenti non necessari con
  [Equatable](/it/faqs/#quando-usare-equatable);
- [RepositoryProvider](/it/flutter-bloc-concepts#repositoryprovider), widget
  Flutter che fornisce un repository ai suoi figli;
- [BlocListener](/it/flutter-bloc-concepts#bloclistener), widget Flutter che
  invoca il codice listener in risposta ai cambiamenti di stato nel bloc;
- [MultiBlocProvider](/it/flutter-bloc-concepts#multiblocprovider), widget
  Flutter che unisce pi√π widget BlocProvider in uno;
- [BlocConsumer](/it/flutter-bloc-concepts#blocconsumer), widget Flutter che
  espone un builder e listener per reagire a nuovi stati;
- [HydratedBloc](https://github.com/felangel/bloc/tree/master/packages/hydrated_bloc)
  per gestire e persistere lo stato.

## Configurazione

Per iniziare, crea un nuovo progetto flutter

<FlutterCreateSnippet />

### Struttura del Progetto

L'app consister√† di funzionalit√† isolate in directory corrispondenti. Questo ci
permette di scalare man mano che il numero di funzionalit√† aumenta e permette
agli sviluppatori di lavorare su funzionalit√† diverse in parallelo.

L'app pu√≤ essere suddivisa in quattro funzionalit√† principali: **search,
settings, theme, weather**. Creiamo quelle directory.

<FeatureTreeSnippet />

### Architettura

Seguendo le linee guida dell'[architettura bloc](/it/architecture),
l'applicazione consister√† di diversi livelli.

In questo tutorial, i diversi livelli avranno i seguenti compiti:

- **Dati**: recuperare dati meteo grezzi dall'API;
- **Repository**: astrarre il livello dati ed esporre modelli di dominio per
  l'applicazione da consumare;
- **Logica Applicativa**: gestire lo stato di ogni funzionalit√† (informazioni
  unit√†, dettagli citt√†, temi, ecc.);
- **Presentazione**: visualizzare informazioni meteo e raccogliere input dagli
  utenti (pagina impostazioni, pagina ricerca ecc.).

## Livello Dati

Per questa applicazione useremo l' [API Open Meteo](https://open-meteo.com).

Ci concentreremo su due endpoint:

- `https://geocoding-api.open-meteo.com/v1/search?name=$city&count=1` per
  ottenere una posizione per un dato nome citt√†;
- `https://api.open-meteo.com/v1/forecast?latitude=$latitude&longitude=$longitude&current_weather=true`
  per ottenere il meteo per una data posizione.

Apri
[https://geocoding-api.open-meteo.com/v1/search?name=chicago&count=1](https://geocoding-api.open-meteo.com/v1/search?name=chicago&count=1)
nel tuo browser per vedere la risposta per la citt√† di Chicago. Useremo la
`latitude` e `longitude` nella risposta per chiamare l'endpoint meteo.

La `latitude`/`longitutde` per Chicago √® `41.85003`/`-87.65005`. Naviga a
[https://api.open-meteo.com/v1/forecast?latitude=43.0389&longitude=-87.90647&current_weather=true](https://api.open-meteo.com/v1/forecast?latitude=43.0389&longitude=-87.90647&current_weather=true)
nel tuo browser e vedrai che la risposta per il meteo a Chicago conterr√† tutti i
dati di cui avremo bisogno per la nostra app.

### OpenMeteo API Client

L'OpenMeteo API Client √® indipendente dalla nostra applicazione. Di conseguenza,
lo creeremo come pacchetto interno (e potremmo persino pubblicarlo su
[pub.dev](https://pub.dev)). Possiamo poi usare il pacchetto aggiungendolo al
`pubspec.yaml` per il livello repository, che gestir√† le richieste dati per la
nostra applicazione meteo principale.

Crea una nuova directory a livello progetto chiamata `packages`. Questa
directory memorizzer√† tutti i nostri pacchetti interni.

All'interno di questa directory, esegui il comando `flutter create` per creare
un nuovo pacchetto chiamato `open_meteo_api` per il nostro client API.

<FlutterCreateApiClientSnippet />

### Modello Dati Meteo

Successivamente, creiamo `location.dart` e `weather.dart` che conterranno i
modelli per le risposte degli endpoint API `location` e `weather`.

<OpenMeteoModelsTreeSnippet />

#### Modello Location

Il modello `location.dart` dovr√† memorizzare i dati restituiti dall'API
location, la cui risposta dovrebbe essere simile alla seguente:

<LocationJsonSnippet />

Ecco il file `location.dart` che memorizza la risposta mostrata sopra:

<LocationDartSnippet />

#### Modello Weather

Successivamente, lavoriamo su `weather.dart`. Il nostro modello meteo dovrebbe
memorizzare i dati restituiti dall'API meteo, la cui risposta dovrebbe essere
simile alla seguente:

<WeatherJsonSnippet />

Ecco il file `weather.dart` che memorizza la risposta di cui sopra:

<WeatherDartSnippet />

### File Barrel

Creiamo rapidamente un
[file "barrel"](https://adrianfaciu.dev/posts/barrel-files/) `models.dart` per
avere un unico file di esportazione per tutti i modelli.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/lib/src/models/models.dart"
	title="packages/open_meteo_api/lib/src/models/models.dart"
/>

Creiamo anche un file "barrel" a livello pacchetto, `open_meteo_api.dart`

<OpenMeteoModelsBarrelTreeSnippet />

Nel livello superiore, `open_meteo_api.dart` esportiamo i modelli:

<OpenMeteoLibrarySnippet />

### Configurazione

Dobbiamo essere in grado di
[serializzare e deserializzare](https://en.wikipedia.org/wiki/Serialization) i
nostri modelli per lavorare con i dati delle API. Per fare questo, aggiungeremo
i metodi `toJson` e `fromJson` ai nostri modelli.

Inoltre, abbiamo bisogno di un modo per
[fare richieste HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
per recuperare i dati da un'API remota. Fortunatamente, ci sono numerosi
pacchetti popolari per fare proprio questo.

Useremo i pacchetti [json_annotation](https://pub.dev/packages/json_annotation),
[json_serializable](https://pub.dev/packages/json_serializable), e
[build_runner](https://pub.dev/packages/build_runner) per generare le
implementazioni `toJson` e `fromJson` per noi.

Successivamente, useremo anche il pacchetto
[http](https://pub.dev/packages/http) per inviare richieste di rete all'API
meteo permettendo alla nostra applicazione di visualizzare i dati meteo
correnti.

Aggiungiamo queste dipendenze al `pubspec.yaml`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/pubspec.yaml"
	title="packages/open_meteo_api/pubspec.yaml"
/>

:::note

Ricorda di eseguire `flutter pub get` dopo aver aggiunto le dipendenze.

:::

### (De)Serializzazione

Affinch√© la generazione del codice funzioni, dobbiamo annotare il nostro codice
usando il seguente:

- `@JsonSerializable` per etichettare classi che possono essere serializzate;
- `@JsonKey` per fornire la rappresentazione dei nomi dei campi;
- `@JsonValue` per fornire la rappresentazioni dei valori dei campi;
- Implementare `JSONConverter` per creare dei convertitori ad-hoc.

Per ogni file dobbiamo anche:

- Importare `json_annotation`;
- Includere il codice generato usando la parola chiave
  [part](https://dart.dev/tools/pub/create-packages#organizing-a-package);
- Includere il metodo `fromJson` per la deserializzazione.

#### Modello Location

Ecco il nostro file `location.dart` completo:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/lib/src/models/location.dart"
	title="packages/open_meteo_api/lib/src/models/location.dart"
/>

#### Modello Weather

Ecco il nostro file `weather.dart` completo:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/lib/src/models/weather.dart"
	title="packages/open_meteo_api/lib/src/models/weather.dart"
/>

#### Crea File Build

Nella cartella `open_meteo_api`, crea un file `build.yaml`. Lo scopo di questo
file √® gestire discrepanze tra convenzioni di nomenclatura nei nomi dei campi
`json_serializable`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/build.yaml"
	title="packages/open_meteo_api/build.yaml"
/>

#### Generazione Codice

Usiamo `build_runner` per generare il codice.

<BuildRunnerBuildSnippet />

`build_runner` dovrebbe generare i file `location.g.dart` e `weather.g.dart`.

### OpenMeteo API Client

Creiamo il nostro client API in `open_meteo_api_client.dart` all'interno della
directory `src` . La struttura del nostro progetto dovrebbe ora essere cos√¨:

<OpenMeteoApiClientTreeSnippet />

Possiamo ora usare il pacchetto [http](https://pub.dev/packages/http) che
abbiamo aggiunto prima al file `pubspec.yaml` per fare richieste HTTP all'API
meteo e usare queste informazioni nella nostra applicazione.

Il nostro client API esporr√† due metodi:

- `locationSearch` che restituisce un `Future<Location>`;
- `getWeather` che restituisce un `Future<Weather>`.

#### Location Search

Il metodo `locationSearch` chiama l'API location e in caso di errore lancia il
fallimento `LocationRequestFailure`. Il metodo completato √® riportato di
seguito:

<LocationSearchMethodSnippet />

#### Get Weather

Allo stesso modo, il metodo `getWeather` chiama l'API meteo e in caso di errore
lancia `WeatherRequestFailure`. Il metodo completato √® cos√¨ definito:

<GetWeatherMethodSnippet />

L'intero file dovrebbe risultare cos√¨:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/lib/src/open_meteo_api_client.dart"
	title="packages/open_meteo_api/lib/src/open_meteo_api_client.dart"
/>

#### Aggiornamenti File Barrel

Concludiamo questo pacchetto aggiungendo il nostro client API al file "barrel".

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/lib/open_meteo_api.dart"
	title="packages/open_meteo_api/lib/open_meteo_api.dart"
/>

### Test Unitari

√à particolarmente importante scrivere test unitari per il livello dati poich√© √®
la fondazione della nostra applicazione. I test unitari ci daranno fiducia che
il pacchetto si comporti come previsto.

#### Configurazione

Prima, abbiamo aggiunto il pacchetto [test](https://pub.dev/packages/test) al
nostro pubspec.yaml che permette di scrivere facilmente test unitari.

Creeremo un file di test per il client API cos√¨ come per i due modelli.

#### Test Location

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/test/location_test.dart"
	title="packages/open_meteo_api/test/location_test.dart"
/>

#### Test Weather

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/test/weather_test.dart"
	title="packages/open_meteo_api/test/weather_test.dart"
/>

#### Test API Client

Successivamente, testiamo il nostro client API. Per assicurarci il corretto
funzionamento dovremmo testare che il nostro client API gestisca entrambe le
chiamate API correttamente, inclusi casi limite.

:::note

Non vogliamo che i nostri test facciano chiamate API reali poich√© il nostro
obiettivo √® testare la logica del client API (inclusi tutti i casi limite) e non
l'API stessa. Per avere un ambiente di test consistente e controllato, useremo
[mocktail](https://github.com/felangel/mocktail) (che abbiamo aggiunto al file
pubspec.yaml prima) per mockare il client `http`.

:::

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/open_meteo_api/test/open_meteo_api_client_test.dart"
	title="packages/open_meteo_api/test/open_meteo_api_client_test.dart"
/>

#### Copertura Test

Infine, verifichiamo la copertura dei test per assicurarci che ogni riga di
codice sia testata almeno una volta.

<FlutterTestCoverageSnippet />

## Livello Repository

L'obiettivo del nostro livello repository √® astrarre il nostro livello dati e
facilitare la comunicazione con il livello bloc. Facendo questo, il resto del
nostro progetto dipender√† solo dalle funzioni esposte e non dalle
implementazioni specifiche dei data provider. Questo ci permette di cambiare
data provider senza invalidare alcuna implementazione al livello applicativo. Ad
esempio, se decidiamo di migrare da questa particolare API meteo, dovremmo
essere in grado di creare un nuovo client API e sostituirlo senza dover fare
cambiamenti all'API pubblica del repository o al livello applicativo.

### Configurazione

All'interno della directory packages, esegui il seguente comando:

<FlutterCreateRepositorySnippet />

Useremo gli stessi pacchetti del pacchetto `open_meteo_api` incluso il pacchetto
`open_meteo_api` definito nel passo precedente. Aggiorna il tuo `pubspec.yaml`
ed esegui `flutter pub get`.

:::note

Stiamo usando un `path` per specificare la posizione di `open_meteo_api` che ci
permette di trattarlo proprio come un pacchetto esterno da `pub.dev`.

:::

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/pubspec.yaml"
	title="packages/weather_repository/pubspec.yaml"
/>

### Modelli Weather Repository

Creeremo un nuovo file `weather.dart` per esporre un modello meteo specifico del
dominio. Questo modello conterr√† solo dati rilevanti per i nostri casi
applicativi -- in altre parole dovrebbe essere completamente disaccoppiato dal
client API . Come al solito, creeremo anche un file "barrel" `models.dart`.

<RepositoryModelsBarrelTreeSnippet />

Questa volta, il nostro modello meteo memorizzer√† solo le propriet√†
`location, temperature, condition`. Continueremo anche ad annotare il nostro
codice per generare il codice di serializzazione e deserializzazione.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/lib/src/models/weather.dart"
	title="packages/weather_repository/lib/src/models/weather.dart"
/>

Aggiorna il file "barrel" che abbiamo creato prima per includere i modelli.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/lib/src/models/models.dart"
	title="packages/weather_repository/lib/src/models/models.dart"
/>

#### Crea File Build

Come prima, dobbiamo creare un file `build.yaml` con il seguente contenuto:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/build.yaml"
	title="packages/weather_repository/build.yaml"
/>

#### Generazione Codice

Come abbiamo fatto prima, esegui il seguente comando per generare l'
implementazione (de)serializzazione.

<BuildRunnerBuildSnippet />

#### File Barrel

Creiamo anche un file "barrel" a livello di pacchetto chiamato
`packages/weather_repository/lib/weather_repository.dart` per esportare i nostri
modelli:

<WeatherRepositoryLibrarySnippet />

### Weather Repository

L'obiettivo principale del `WeatherRepository` √® fornire un'interfaccia che
astrae il data provider. In questo caso, il `WeatherRepository` avr√† una
dipendenza sul `WeatherApiClient` ed esporr√† un singolo metodo pubblico,
`getWeather(String city)`.

:::note

I consumatori del `WeatherRepository` non sono a conoscenza dei dettagli di
implementazione sottostanti come il fatto che vengono fatte due richieste di
rete all' API meteo. L'obiettivo del `WeatherRepository` √® separare il "cosa"
dal "come" -- in altre parole, vogliamo avere un modo per recuperare il meteo
per una data citt√†, ma non ci interessa come o da dove provengono quei dati.

:::

#### Configurazione

Creiamo il file `weather_repository.dart` all'interno della directory `src` del
nostro pacchetto e lavoriamo sull'implementazione del repository.

Il metodo principale su cui ci concentreremo √® `getWeather(String city)`.
Possiamo implementarlo usando due chiamate al client API come segue:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/lib/src/weather_repository.dart"
	title="packages/weather_repository/lib/src/weather_repository.dart"
/>

#### File Barrel

Aggiorna il file "barrel" che abbiamo creato prima.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/lib/weather_repository.dart"
	title="packages/weather_repository/lib/weather_repository.dart"
/>

### Test Unitari

Proprio come con il livello dati, √® critico testare il livello repository per
assicurarci che la logica a livello dominio sia corretta. Per testare il nostro
`WeatherRepository`, useremo la libreria
[mocktail](https://github.com/felangel/mocktail). Mockeremo il client API
sottostante per testare unitariamente la logica `WeatherRepository` in un
ambiente isolato e controllato.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/packages/weather_repository/test/weather_repository_test.dart"
	title="packages/weather_repository/test/weather_repository_test.dart"
/>

## Livello Logica Applicativa

Nel livello di logica applicativa, consumeremo il modello meteo di dominio dal
`WeatherRepository` ed esporremo un nuovo modello a livello di funzionalit√† che
sar√† mostrato all'utente tramite l'interfaccia.

:::note

Questo √® il terzo diverso tipo di modello meteo che stiamo implementando. Nel
client API , il nostro modello meteo conteneva tutte le informazioni restituite
dall'API. Nel livello repository, il nostro modello meteo conteneva solo il
modello astratto basato sul nostro caso applicativo. In questo strato, il nostro
modello meteo conterr√† le sole informazioni rilevanti necessarie per il set di
funzionalit√† corrente.

:::

### Configurazione

Poich√© il nostro livello di logica applicativa risiede nella nostra app
principale, dobbiamo modificare il `pubspec.yaml` per l'intero progetto
`flutter_weather` e includere tutti i pacchetti che useremo.

- Usare [equatable](https://pub.dev/packages/equatable) permetter√† alle istanze
  delle classi di essere confrontate (`==`) per valore. Sotto il cofano, bloc
  confronter√† i nostri stati per vedere se sono uguali, e se non lo sono,
  attiver√† un aggiornamento. Questo garantisce che il nostro albero dei widget
  si ricostruisca solo quando necessario per mantenere le prestazioni veloci e
  reattive;
- Possiamo ravvivare la nostra interfaccia utente con
  [google_fonts](https://pub.dev/packages/google_fonts);
- [HydratedBloc](https://pub.dev/packages/hydrated_bloc) ci permette di
  persistere lo stato dell'applicazione quando l'app viene chiusa e riaperta;
- Includeremo il pacchetto `weather_repository` che abbiamo appena creato per
  permetterci di recuperare i dati meteo correnti.

Per i test, vorremmo includere il solito pacchetto `test`, insieme a `mocktail`
per mockare dipendenze e [bloc_test](https://pub.dev/packages/bloc_test), per
abilitare test facili di unit√† di logica applicativa, o bloc!

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/pubspec.yaml"
	title="pubspec.yaml"
/>

Successivamente, lavoreremo sul livello applicativo all'interno della directory
`weather` .

### Modello Weather

L'obiettivo del nostro modello meteo √® tenere traccia dei dati meteo
visualizzati dalla nostra app, cos√¨ come l'unit√† di misura della temperatura
(Celsius o Fahrenheit).

Crea `flutter_weather/lib/weather/models/weather.dart`:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/models/weather.dart"
	title="lib/weather/models/weather.dart"
/>

### Crea File Build

Crea un file `build.yaml` per il livello di logica applicativa.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/build.yaml"
	title="build.yaml"
/>

### Generazione Codice

Esegui `build_runner` per generare le implementazioni (de)serializzazione.

<BuildRunnerBuildSnippet />

### File Barrel

Esportiamo i nostri modelli dal file "barrel"
(`flutter_weather/lib/weather/models/models.dart`):

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/models/models.dart"
	title="lib/weather/models/models.dart"
/>

Poi, creiamo un file "barrel" weather di livello superiore
(`flutter_weather/lib/weather/weather.dart`);

<WeatherBarrelDartSnippet />

### Weather

Useremo `HydratedCubit` per abilitare la nostra app a ricordare il suo stato
dell'applicazione, anche dopo che √® stata chiusa e riaperta.

:::note

`HydratedCubit` √® un'estensione di `Cubit` che gestisce la persistenza e
ripristino dello stato tra le sessioni.

:::

#### Weather State

Usando l'
[Estensione Bloc VSCode](https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc)
o [Plugin Bloc IntelliJ](https://plugins.jetbrains.com/plugin/12129-bloc), fai
clic destro sulla directory `weather` e crea un nuovo cubit chiamato `Weather`.
La struttura del progetto dovrebbe essere cos√¨:

<WeatherCubitTreeSnippet />

Ci sono quattro stati in cui la nostra app meteo pu√≤ essere:

- `initial` prima che qualcosa si carichi;
- `loading` durante la chiamata API;
- `success` se la chiamata API ha successo;
- `failure` se la chiamata API non ha successo.

L'enum `WeatherStatus` rappresenter√† quanto sopra.

Lo stato meteo completo dovrebbe essere cos√¨:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/cubit/weather_state.dart"
	title="lib/weather/cubit/weather_state.dart"
/>

#### Weather Cubit

Ora che abbiamo definito il `WeatherState`, scriviamo il `WeatherCubit` che
esporr√† i seguenti metodi:

- `fetchWeather(String? city)` usa il nostro weather repository per provare a
  recuperare un oggetto meteo per la citt√† data;
- `refreshWeather()` recupera un nuovo oggetto meteo usando il weather
  repository dato lo stato meteo corrente;
- `toggleUnits()` attiva/disattiva lo stato tra Celsius e Fahrenheit;
- `fromJson(Map<String, dynamic> json)`, `toJson(WeatherState state)` usati per
  persistenza.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/cubit/weather_cubit.dart"
	title="lib/weather/cubit/weather_cubit.dart"
/>

:::note

Ricorda di generare il codice (de)serializzazione tramite:

<BuildRunnerBuildSnippet />
:::

### Test Unitari

Simile ai livelli dati e repository, √® critico testare unitariamente il livello
di logica applicativa per assicurarci che la logica a livello di funzionalit√† si
comporti come ci aspettiamo. Ci affideremo a
[bloc_test](https://pub.dev/packages/bloc_test) in aggiunta a `mocktail` e
`test`.

Aggiungiamo i pacchetti `test`, `bloc_test`, e `mocktail` alle
`dev_dependencies`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/pubspec.yaml"
	title="pubspec.yaml"
/>

:::note

Il pacchetto [bloc_test](https://pub.dev/packages/bloc_test) ci permette di
preparare facilmente i nostri bloc per i test, gestire i cambiamenti di stato e
controllare i risultati in un modo consistente.

:::

#### Test Weather Cubit

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/test/weather/cubit/weather_cubit_test.dart"
	title="test/weather/cubit/weather_cubit_test.dart"
/>

## Livello Presentazione

### Weather Page

Inizieremo con la `WeatherPage` che usa `BlocProvider` per fornire un'istanza
del `WeatherCubit` all'albero dei widget.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/view/weather_page.dart"
	title="lib/weather/view/weather_page.dart"
/>

Noterai che la pagina dipende dai widget `SettingsPage` e `SearchPage`, che
creeremo successivamente.

### SettingsPage

La pagina impostazioni permette agli utenti di aggiornare le loro preferenze per
l'unit√† di misura della temperatura.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/settings/view/settings_page.dart"
	title="lib/settings/view/settings_page.dart"
/>

### SearchPage

La pagina ricerca permette agli utenti di inserire il nome della loro citt√†
desiderata e fornisce il risultato della ricerca alla route precedente tramite
`Navigator.of(context).pop`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/search/view/search_page.dart"
	title="lib/search/view/search_page.dart"
/>

### Widget Weather

L'app visualizzer√† componenti diversi a seconda dei quattro possibili stati del
`WeatherCubit`.

#### WeatherEmpty

Questo widget verr√† mostrato quando non ci sono dati da visualizzare perch√©
l'utente non ha ancora selezionato una citt√†.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/widgets/weather_empty.dart"
	title="lib/weather/widgets/weather_empty.dart"
/>

#### WeatherError

Questo componente verr√† visualizzato in presenza di un errore.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/widgets/weather_error.dart"
	title="lib/weather/widgets/weather_error.dart"
/>

#### WeatherLoading

Questo widget verr√† visualizzato mentre l'applicazione recupera i dati.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/widgets/weather_loading.dart"
	title="lib/weather/widgets/weather_loading.dart"
/>

#### WeatherPopulated

Questa componente verr√† visualizzato una volta che l'utente ha selezionato una
citt√† e vengono recuperati i dati.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/widgets/weather_populated.dart"
	title="lib/weather/widgets/weather_populated.dart"
/>

### File Barrel

Aggiungiamo questi widget a un file "barrel" per pulire i nostri import.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/weather/widgets/widgets.dart"
	title="lib/weather/widgets/widgets.dart"
/>

### Entrypoint

Il nostro file `main.dart` dovrebbe inizializzare la nostra `WeatherApp` e
`BlocObserver` (per scopi di debug), cos√¨ come impostare il nostro
`HydratedStorage` per persistere lo stato tra le sessioni.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/main.dart"
	title="lib/main.dart"
/>

Il nostro widget `app.dart` gestir√† la costruzione della vista `WeatherPage` che
abbiamo precedentemente creato e user√† `BlocProvider` per iniettare il nostro
`WeatherCubit`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/lib/app.dart"
	title="lib/app.dart"
/>

### Test Widget

La libreria [`bloc_test`](https://pub.dev/packages/bloc_test) espone anche
`MockBlocs` e `MockCubits` che rendono facile testare l'UI. Possiamo mockare gli
stati dei vari cubit e assicurarci che l'UI reagisca correttamente.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_weather/test/weather/view/weather_page_test.dart"
	title="test/weather/view/weather_page_test.dart"
/>

:::note

Stiamo usando un `MockWeatherCubit` insieme all'API `when` da `mocktail` per
simulare (stub) lo stato del cubit in ognuno dei casi di test. Questo ci
permette di simulare tutti gli stati e verificare che l'interfaccia si comporti
correttamente in tutte le circostanze.

:::

## Riepilogo

Questo √® tutto, abbiamo completato il tutorial! üéâ

Possiamo eseguire l'app finale usando il comando `flutter run`.

Il codice sorgente completo per questo esempio, inclusi test unitari e widget,
pu√≤ essere trovato
[qui](https://github.com/felangel/bloc/tree/master/examples/flutter_weather).
