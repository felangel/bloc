---
title: Flutter Login
description:
  Una guida approfondita su come costruire un flusso di login Flutter con bloc.
sidebar:
  order: 4
---

import RemoteCode from '~/components/code/RemoteCode.astro';
import FlutterCreateSnippet from '~/components/tutorials/flutter-login/FlutterCreateSnippet.astro';
import FlutterPubGetSnippet from '~/components/tutorials/FlutterPubGetSnippet.astro';

![intermediate](https://img.shields.io/badge/level-intermediate-orange.svg)

In questo tutorial, costruiremo un flusso per accedere al sistema, in Flutter,
usando la libreria bloc.

![demo](~/assets/tutorials/flutter-login.gif)

## Argomenti Chiave

- [BlocProvider](/it/flutter-bloc-concepts#blocprovider), widget Flutter che
  fornisce un bloc ai suoi figli;
- Aggiungere eventi con [context.read](/it/flutter-bloc-concepts#contextread);
- Prevenire aggiornamenti non necessari con
  [Equatable](/it/faqs#when-to-use-equatable);
- [RepositoryProvider](/it/flutter-bloc-concepts#repositoryprovider), widget
  Flutter che fornisce un repository ai suoi figli;
- [BlocListener](/it/flutter-bloc-concepts#bloclistener), widget Flutter che
  invoca il codice listener in risposta ai cambiamenti di stato nel bloc;
- Aggiornare l'UI basata su una parte di uno stato bloc con
  [context.select](/it/flutter-bloc-concepts#contextselect).

## Configurazione del Progetto

Inizieremo creando un nuovo progetto Flutter

<FlutterCreateSnippet />

Successivamente, possiamo installare tutte le nostre dipendenze

<FlutterPubGetSnippet />

## Authentication Repository

La prima cosa che faremo è creare un pacchetto `authentication_repository` che
sarà responsabile di gestire il dominio della autenticazione.

Inizieremo creando una directory `packages` alla radice del progetto che
conterrà tutti i pacchetti interni. Dopodiché aggiungiamo la directory
`packages/authentication_repository`.

Ad alto livello, la struttura della directory dovrebbe essere così:

```
├── android
├── ios
├── lib
├── packages
│   └── authentication_repository
└── test
```

Successivamente, possiamo creare un `pubspec.yaml` per il pacchetto
`authentication_repository`:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/authentication_repository/pubspec.yaml"
	title="packages/authentication_repository/pubspec.yaml"
/>

:::note

`package:authentication_repository` sarà un pacchetto Dart puro senza alcuna
dipendenza esterna.

:::

Successivamente, dobbiamo implementare la classe `AuthenticationRepository`
stessa che sarà in
`packages/authentication_repository/lib/src/authentication_repository.dart`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/authentication_repository/lib/src/authentication_repository.dart"
	title="packages/authentication_repository/lib/src/authentication_repository.dart"
/>

L'`AuthenticationRepository` espone uno `Stream` di aggiornamenti
`AuthenticationStatus` che sarà usato per notificare l'applicazione quando un
utente accede o esce.

Inoltre, ci sono metodi `logIn` e `logOut` che sono simulati (stub) per
semplicità ma possono essere facilmente estesi per autenticare con
`FirebaseAuth` per esempio o qualche altro provider di autenticazione.

:::note

Poiché stiamo mantenendo un `StreamController` internamente, un metodo `dispose`
è esposto così che il controller possa essere chiuso quando non è più
necessario.

:::

Infine, dobbiamo creare
`packages/authentication_repository/lib/authentication_repository.dart` che
conterrà le esportazioni pubbliche:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/authentication_repository/lib/authentication_repository.dart"
	title="packages/authentication_repository/lib/authentication_repository.dart"
/>

Questo è tutto per l'`AuthenticationRepository`, successivamente lavoreremo sul
`UserRepository`.

## User Repository

Proprio come con l'`AuthenticationRepository`, creeremo un pacchetto
`user_repository` all'interno della directory `packages`.

```
├── android
├── ios
├── lib
├── packages
│   ├── authentication_repository
│   └── user_repository
└── test
```

Successivamente, creeremo il `pubspec.yaml` per il `user_repository`:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/user_repository/pubspec.yaml"
	title="packages/user_repository/pubspec.yaml"
/>

Il `user_repository` sarà responsabile del dominio utente ed esporrà API per
interagire con l'utente corrente.

La prima cosa che definiremo è il modello utente in
`packages/user_repository/lib/src/models/user.dart`:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/user_repository/lib/src/models/user.dart"
	title="packages/user_repository/lib/src/models/user.dart"
/>

Per semplicità, un utente ha solo una proprietà `id` ma potremmo aggiungere
proprietà quali `firstName`, `lastName`, `avatarUrl`, ecc...

:::note

[`package:equatable`](https://pub.dev/packages/equatable) è usato per
confrontare le istanze `User` per valore e non per riferimento.

:::

Successivamente, possiamo creare un `models.dart` in
`packages/user_repository/lib/src/models` che esporterà tutti i modelli. In
questo modo possiamo usare un singolo import per importare più modelli.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/user_repository/lib/src/models/models.dart"
	title="packages/user_repository/lib/src/models/models.dart"
/>

Ora che i modelli sono stati definiti, possiamo implementare la classe
`UserRepository` in `packages/user_repository/lib/src/user_repository.dart`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/user_repository/lib/src/user_repository.dart"
	title="packages/user_repository/lib/src/user_repository.dart"
/>

Per questo semplice esempio, il `UserRepository` espone un singolo metodo
`getUser` che recupererà l'utente corrente. Stiamo simulando una risposta (stub)
ma nella pratica sarebbe il posto dove interrogheremmo l'utente corrente dal
backend.

Abbiamo quasi finito con il pacchetto `user_repository` -- l'unica cosa che
resta da fare è creare il file `user_repository.dart` in
`packages/user_repository/lib` che definisce cosa esportare pubblicamente:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/packages/user_repository/lib/user_repository.dart"
	title="packages/user_repository/lib/user_repository.dart"
/>

Ora che abbiamo completato i pacchetti `authentication_repository` e
`user_repository`, possiamo concentrarci sull'applicazione Flutter.

## Installare Dipendenze

Iniziamo aggiornando il `pubspec.yaml` generato alla radice del nostro progetto:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/pubspec.yaml"
	title="pubspec.yaml"
/>

Possiamo installare le dipendenze eseguendo:

<FlutterPubGetSnippet />

## Authentication Bloc

L'`AuthenticationBloc` sarà responsabile di reagire ai cambiamenti nello stato
di autenticazione (esposto dall'`AuthenticationRepository`) ed emetterà stati a
cui possiamo reagire nel livello di presentazione.

L'implementazione per l'`AuthenticationBloc` è all'interno di
`lib/authentication` perché trattiamo l'autenticazione come una funzionalità nel
nostro livello applicazione.

```
├── lib
│   ├── app.dart
│   ├── authentication
│   │   ├── authentication.dart
│   │   └── bloc
│   │       ├── authentication_bloc.dart
│   │       ├── authentication_event.dart
│   │       └── authentication_state.dart
│   ├── main.dart
```

:::tip

Usa l'
[Estensione VSCode](https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc)
o [Plugin IntelliJ](https://plugins.jetbrains.com/plugin/12129-bloc) per creare
bloc automaticamente.

:::

### authentication_event.dart

Le istanze `AuthenticationEvent` saranno l'input dell'`AuthenticationBloc` e
saranno processate e usate per emettere nuove istanze `AuthenticationState`.

In questa applicazione, l'`AuthenticationBloc` reagirà a due diversi eventi:

- `AuthenticationSubscriptionRequested`: evento iniziale che notifica il bloc di
  sottoscriversi allo stream `AuthenticationStatus`;
- `AuthenticationLogoutPressed`: notifica il bloc di un'azione di logout
  dell'utente.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/authentication/bloc/authentication_event.dart"
	title="lib/authentication/bloc/authentication_event.dart"
/>

Successivamente, diamo un'occhiata all'`AuthenticationState`.

### authentication_state.dart

Le istanze `AuthenticationState` saranno l'output dell'`AuthenticationBloc` e
saranno consumate dal livello di presentazione.

La classe `AuthenticationState` ha tre costruttori nominati:

- `AuthenticationState.unknown()`: lo stato di default che indica che il bloc
  non sa ancora se l'utente corrente è autenticato o meno;

- `AuthenticationState.authenticated()`: lo stato che indica che l'utente è
  attualmente autenticato;

- `AuthenticationState.unauthenticated()`: lo stato che indica che l'utente non
  è attualmente autenticato.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/authentication/bloc/authentication_state.dart"
	title="lib/authentication/bloc/authentication_state.dart"
/>

Ora che abbiamo visto le implementazioni di `AuthenticationEvent` e
`AuthenticationState` diamo un'occhiata all'`AuthenticationBloc`.

### authentication_bloc.dart

L'`AuthenticationBloc` gestisce lo stato di autenticazione dell'applicazione.
Tra i molteplici usi è adoperato per determinare la rotta, login o home page,
dove l'utente farà l'accesso.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/authentication/bloc/authentication_bloc.dart"
	title="lib/authentication/bloc/authentication_bloc.dart"
/>

L'`AuthenticationBloc` ha una dipendenza sia sull'`AuthenticationRepository` che
sul `UserRepository` e definisce lo stato iniziale come
`AuthenticationState.unknown()`.

Nel corpo del costruttore, le sottoclassi di `AuthenticationEvent` sono mappate
ai loro corrispondenti gestori di eventi.

Nel gestore di eventi `_onSubscriptionRequested`, l'`AuthenticationBloc` usa
`emit.onEach` per sottoscriversi allo stream `status` dell'
`AuthenticationRepository` ed emettere uno stato in risposta a ogni
`AuthenticationStatus`.

`emit.onEach` crea una sottoscrizione internamente e si occupa di cancellarla
quando l'`AuthenticationBloc` o lo stream `status` è chiuso.

Se lo stream `status` emette un errore, `addError` inoltra l'errore e lo
stackTrace a qualsiasi `BlocObserver` in ascolto.

:::caution

Se `onError` è omesso, eventuali errori sullo stream `status` sono considerati
non gestiti, e saranno lanciati da `onEach`. Di conseguenza, la sottoscrizione
allo stream `status` sarà cancellato.

:::

:::tip

Un [`BlocObserver`](/it/bloc-concepts/#blocobserver-1) è ottimo per registrare
ad eventi Bloc, errori e cambiamenti di stato specialmente nel contesto di
analytics e crash reporting.;

:::

Quando lo stream `status` emette `AuthenticationStatus.unknown` o
`unauthenticated`, viene emesso lo `AuthenticationState` corrispondente.

Quando viene emesso `AuthenticationStatus.authenticated`, l'`AuthentictionBloc`
interroga l'utente tramite il `UserRepository`.

## main.dart

Successivamente, possiamo sostituire il `main.dart` di default con:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/main.dart"
	title="lib/main.dart"
/>

## App

`app.dart` conterrà il widget `App` root per l'intera applicazione.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/app.dart"
	title="lib/app.dart"
/>

:::note

`app.dart` è diviso in due parti `App` e `AppView`. `App` è responsabile di
creare/fornire l'`AuthenticationBloc` che sarà consumato dal `AppView`. Questo
disaccoppiamento ci permetterà in seguito di testare facilmente sia il widget
`App` che `AppView`.

:::

:::note

`RepositoryProvider` è usato per fornire la singola istanza di
`AuthenticationRepository` all'intera applicazione. Più tardi vedremo come
tornerà utile.

:::

Di default, `BlocProvider` è lazy e non chiama `create` fino alla prima volta in
cui viene richiesto l'accesso al Bloc. Poiché `AuthenticationBloc` dovrebbe
sempre sottoscriversi immediatamente allo stream `AuthenticationStatus` (tramite
l'evento `AuthenticationSubscriptionRequested`), possiamo esplicitamente
rifiutare questo comportamento impostando `lazy: false`.

`AppView` è un `StatefulWidget` perché mantiene una `GlobalKey` che è usata per
accedere al `NavigatorState`. Di default, `AppView` renderizzerà la `SplashPage`
(che vedremo dopo) e usa `BlocListener` per navigare a pagine diverse in base ai
cambiamenti nell'`AuthenticationState`.

## Splash

La funzionalità splash conterrà solo una vista semplice che sarà renderizzata
quando l'app viene avviata mentre l'app determina se l'utente è autenticato.

```
lib
└── splash
    ├── splash.dart
    └── view
        └── splash_page.dart
```

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/splash/view/splash_page.dart"
	title="lib/splash/view/splash_page.dart"
/>

:::tip

`SplashPage` espone una `Route` statica che rende molto facile navigare tramite
`Navigator.of(context).push(SplashPage.route())`;

:::

## Login

La funzionalità login contiene una `LoginPage`, `LoginForm` e `LoginBloc` e
permette agli utenti di inserire un username e password per accedere
all'applicazione.

```
├── lib
│   ├── login
│   │   ├── bloc
│   │   │   ├── login_bloc.dart
│   │   │   ├── login_event.dart
│   │   │   └── login_state.dart
│   │   ├── login.dart
│   │   ├── models
│   │   │   ├── models.dart
│   │   │   ├── password.dart
│   │   │   └── username.dart
│   │   └── view
│   │       ├── login_form.dart
│   │       ├── login_page.dart
│   │       └── view.dart
```

### Modelli Login

Stiamo usando [`package:formz`](https://pub.dev/packages/formz) per creare
modelli riutilizzabili e standard per `username` e `password`.

#### Username

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/models/username.dart"
	title="lib/login/models/username.dart"
/>

Per semplicità, stiamo solo validando l'username per assicurarci che non sia
vuoto ma nella pratica puoi imporre l'uso di caratteri speciali, lunghezza,
ecc...

#### Password

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/models/password.dart"
	title="lib/login/models/password.dart"
/>

Anche per la password stiamo semplicemente eseguendo un controllo per
assicurarci non sia vuota.

#### Barrel Modelli

Proprio come prima, c'è un "barrel" `models.dart` per rendere facile importare i
modelli `Username` e `Password` con un singolo import.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/models/models.dart"
	title="lib/login/models/models.dart"
/>

### Login Bloc

Il `LoginBloc` gestisce lo stato del `LoginForm` e si occupa di validare l'input
username e password così come lo stato del form.

#### login_event.dart

In questa applicazione ci sono tre diversi tipi di `LoginEvent`:

- `LoginUsernameChanged`: notifica il bloc che l'username è stato modificato;
- `LoginPasswordChanged`: notifica il bloc che la password è stata modificata;
- `LoginSubmitted`: notifica il bloc che il form è stato inviato.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/bloc/login_event.dart"
	title="lib/login/bloc/login_event.dart"
/>

#### login_state.dart

Il `LoginState` conterrà lo stato del form così come gli stati di input username
e password.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/bloc/login_state.dart"
	title="lib/login/bloc/login_state.dart"
/>

:::note

I modelli `Username` e `Password` sono usati come parte del `LoginState` e lo
status fa anche parte di [package:formz](https://pub.dev/packages/formz).

:::

#### login_bloc.dart

Il `LoginBloc` è responsabile di reagire alle interazioni dell'utente nel
`LoginForm` e gestire la validazione e l'invio del form.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/bloc/login_bloc.dart"
	title="lib/login/bloc/login_bloc.dart"
/>

Il `LoginBloc` ha una dipendenza sull'`AuthenticationRepository` perché quando
il form viene inviato, invoca `logIn`. Lo stato iniziale del bloc è `pure` il
che significa che non c'è stata alcuna interazione né con gli input né con il
form.

Ogni volta che `username` o `password` cambiano, il bloc creerà una variante
`dirty` del modello `Username`/`Password` e aggiornerà lo stato del form tramite
l'API `Formz.validate`.

Quando viene aggiunto l'evento `LoginSubmitted`, se lo stato corrente del form è
valido, il bloc fa una chiamata a `logIn` e aggiorna lo stato in base al
risultato della richiesta.

Diamo ora un'occhiata alla `LoginPage` e alla `LoginForm`.

### Login Page

La `LoginPage` è responsabile di esporre la `Route` così come creare e fornire
il `LoginBloc` al `LoginForm`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/view/login_page.dart"
	title="lib/login/view/login_page.dart"
/>

:::note

`context.read<AuthenticationRepository>()` è usato per cercare l'istanza di
`AuthenticationRepository` tramite il `BuildContext`.

:::

### Login Form

Il `LoginForm` notifica gli eventi generati dall'utente al `LoginBloc` risponde
ai cambiamenti di stato attraverso `BlocBuilder` e `BlocListener`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/login/view/login_form.dart"
	title="lib/login/view/login_form.dart"
/>

`BlocListener` è usato per mostrare uno `SnackBar` se l'invio del login
fallisce. In aggiunta, `context.select` è usato in ogni widget per accedere
efficientemente a parti specifiche del `LoginState`, prevenendo aggiornamenti
non necessari. La callback `onChanged` è usato per notificare il `LoginBloc` dei
cambiamenti a username/password.

Il widget `_LoginButton` è abilitato solo se lo stato del form è valido e un
`CircularProgressIndicator` è mostrato al suo posto mentre il form viene
inviato.

## Home

Dopo una richiesta `logIn` di successo, lo stato dell'`AuthenticationBloc`
cambierà a `authenticated` e l'utente sarà riportato alla `HomePage` dove
visualizziamo l'`id` dell'utente così come un pulsante per disconnettersi.

```
├── lib
│   ├── home
│   │   ├── home.dart
│   │   └── view
│   │       └── home_page.dart
```

### Home Page

La `HomePage` può accedere all'id utente corrente tramite
`context.select((AuthenticationBloc bloc) => bloc.state.user.id)` e lo
visualizza tramite un widget `Text`. Inoltre, quando viene toccato il pulsante
logout, un evento `AuthenticationLogoutPressed` viene aggiunto
all'`AuthenticationBloc`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_login/lib/home/view/home_page.dart"
	title="lib/home/view/home_page.dart"
/>

:::note

`context.select((AuthenticationBloc bloc) => bloc.state.user.id)` renderizzerà
nuovamente `Text` solo se l'id utente cambia.

:::

A questo punto abbiamo un'implementazione di login abbastanza solida e abbiamo
disaccoppiato il nostro livello di presentazione dal livello di logica
applicativa usando Bloc.

Il codice sorgente completo per questo esempio (inclusi test unitari e widget)
può essere trovato
[qui](https://github.com/felangel/Bloc/tree/master/examples/flutter_login).
