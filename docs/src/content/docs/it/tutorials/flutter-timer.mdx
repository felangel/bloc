---
title: Flutter Timer
description: Una guida approfondita su come costruire un'app Flutter timer con bloc.
sidebar:
  order: 2
---

import RemoteCode from '~/components/code/RemoteCode.astro';
import FlutterCreateSnippet from '~/components/tutorials/flutter-timer/FlutterCreateSnippet.astro';
import TimerBlocEmptySnippet from '~/components/tutorials/flutter-timer/TimerBlocEmptySnippet.astro';
import TimerBlocInitialStateSnippet from '~/components/tutorials/flutter-timer/TimerBlocInitialStateSnippet.astro';
import TimerBlocTickerSnippet from '~/components/tutorials/flutter-timer/TimerBlocTickerSnippet.astro';
import TimerBlocOnStartedSnippet from '~/components/tutorials/flutter-timer/TimerBlocOnStartedSnippet.astro';
import TimerBlocOnTickedSnippet from '~/components/tutorials/flutter-timer/TimerBlocOnTickedSnippet.astro';
import TimerBlocOnPausedSnippet from '~/components/tutorials/flutter-timer/TimerBlocOnPausedSnippet.astro';
import TimerBlocOnResumedSnippet from '~/components/tutorials/flutter-timer/TimerBlocOnResumedSnippet.astro';
import TimerPageSnippet from '~/components/tutorials/flutter-timer/TimerPageSnippet.astro';
import ActionsSnippet from '~/components/tutorials/flutter-timer/ActionsSnippet.astro';
import BackgroundSnippet from '~/components/tutorials/flutter-timer/BackgroundSnippet.astro';

![beginner](https://img.shields.io/badge/level-beginner-green.svg)

In questo tutorial vedremo come costruire un timer
usando la libreria bloc. L'applicazione risultante dovrebbe essere così:

![demo](~/assets/tutorials/flutter-timer.gif)

## Argomenti Chiave

- Osservare i cambiamenti di stato con [BlocObserver](/it/bloc-concepts#blocobserver);
- [BlocProvider](/it/flutter-bloc-concepts#blocprovider), widget Flutter che
  fornisce un bloc ai suoi figli;
- [BlocBuilder](/it/flutter-bloc-concepts#blocbuilder), widget Flutter che gestisce
  la costruzione del widget in risposta a nuovi stati;
- Prevenire aggiornamenti non necessari con [Equatable](/it/faqs#when-to-use-equatable);
- Imparare a usare `StreamSubscription` in un Bloc;
- Prevenire aggiornamenti non necessari con `buildWhen`.

## Configurazione

Inizieremo creando un nuovo progetto Flutter:

<FlutterCreateSnippet />

Possiamo poi sostituire il contenuto di pubspec.yaml con:

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/pubspec.yaml"
	title="pubspec.yaml"
/>

:::note

Useremo i pacchetti [flutter_bloc](https://pub.dev/packages/flutter_bloc) e
[equatable](https://pub.dev/packages/equatable) in questa app.

:::

Successivamente, esegui `flutter pub get` per installare tutte le dipendenze.

## Struttura del Progetto

```
├── lib
|   ├── timer
│   │   ├── bloc
│   │   │   └── timer_bloc.dart
|   |   |   └── timer_event.dart
|   |   |   └── timer_state.dart
│   │   └── view
│   │   |   ├── timer_page.dart
│   │   ├── timer.dart
│   ├── app.dart
│   ├── ticker.dart
│   └── main.dart
├── pubspec.lock
├── pubspec.yaml
```

## Ticker

Il ticker sarà la sorgente di dati per l'applicazione timer. Esporrà uno
stream di "tick" a cui possiamo sottoscriverci e reagire.

Inizia creando `ticker.dart`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/ticker.dart"
	title="lib/ticker.dart"
/>

Tutto ciò che fa la classe `Ticker` è esporre una funzione `tick` che prende il numero di
tick (secondi) che vogliamo e restituisce uno stream che emette i secondi rimanenti
ogni secondo.

Successivamente, dobbiamo creare il `TimerBloc` che consumerà il `Ticker`.

## Timer Bloc

### TimerState

Inizieremo definendo i `TimerStates` in cui il `TimerBloc` può trovarsi.

Lo stato del `TimerBloc` può essere uno dei seguenti:

- `TimerInitial`: pronto per iniziare il conteggio alla rovescia dalla durata specificata.
- `TimerRunInProgress`: sta attivamente contando alla rovescia dalla durata specificata.
- `TimerRunPause`: in pausa a una durata rimanente.
- `TimerRunComplete`: completato con una durata rimanente di 0.

Ognuno di questi stati avrà un'implicazione sull'interfaccia utente e sulle azioni
che l'utente può eseguire. Ad esempio:

- se lo stato è `TimerInitial` l'utente sarà in grado di avviare il timer;
- se lo stato è `TimerRunInProgress` l'utente sarà in grado di mettere in pausa e resettare
  il timer così come vedere la durata rimanente;
- se lo stato è `TimerRunPause` l'utente sarà in grado di riprendere il timer e
  resettare il timer;
- se lo stato è `TimerRunComplete` l'utente sarà in grado di resettare il timer.

Per mantenere tutti i nostri file bloc insieme, creiamo una directory bloc
con `bloc/timer_state.dart`.

:::tip

Puoi usare le
[IntelliJ](https://plugins.jetbrains.com/plugin/12129-bloc-code-generator) o
[VSCode](https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc)
estensioni per autogenerare i seguenti file bloc per te.

:::

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/timer/bloc/timer_state.dart"
	title="lib/timer/bloc/timer_state.dart"
/>

Nota che tutti i `TimerStates` estendono la classe base astratta `TimerState`
che ha una proprietà duration. Questo è perché non importa in quale stato il nostro
`TimerBloc` sia, vogliamo sempre sapere quanto tempo rimane. Inoltre,
`TimerState` estende `Equatable` per ottimizzare il nostro codice assicurandoci che la nostra app
non attivi aggiornamenti se viene emesso uno stato uguale al precedente.

Successivamente, definiamo e implementiamo i `TimerEvents` che il nostro `TimerBloc`
processerà.

### TimerEvent

Il nostro `TimerBloc` dovrà sapere come processare i seguenti eventi:

- `TimerStarted`: informa il TimerBloc che il timer dovrebbe essere avviato;
- `TimerPaused`: informa il TimerBloc che il timer dovrebbe essere messo in pausa;
- `TimerResumed`: informa il TimerBloc che il timer dovrebbe essere ripreso;
- `TimerReset`: informa il TimerBloc che il timer dovrebbe essere resettato allo
  stato originale;
- `_TimerTicked`: informa il TimerBloc che si è verificato un tick e che deve
  aggiornare il suo stato di conseguenza.

Se non hai usato le
[IntelliJ](https://plugins.jetbrains.com/plugin/12129-bloc-code-generator) o
[VSCode](https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc)
estensioni, crea `bloc/timer_event.dart` e implementiamo quegli eventi.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/timer/bloc/timer_event.dart"
	title="lib/timer/bloc/timer_event.dart"
/>

Successivamente, implementiamo il `TimerBloc`!

### TimerBloc

Se non l'hai già fatto, crea `bloc/timer_bloc.dart` e crea un `TimerBloc`
vuoto.

<TimerBlocEmptySnippet />

La prima cosa che dobbiamo fare è definire lo stato iniziale del nostro `TimerBloc`. In
questo caso, vogliamo che il `TimerBloc` inizi nello stato `TimerInitial` con
una durata preimpostata di 1 minuto (60 secondi).

<TimerBlocInitialStateSnippet />

Successivamente, dobbiamo definire la dipendenza sul nostro `Ticker`.

<TimerBlocTickerSnippet />

Stiamo anche definendo una `StreamSubscription` per il nostro `Ticker` che implementeremo
tra poco.

A questo punto, tutto ciò che resta da fare è implementare i gestori di eventi. Per
migliorare la leggibilità, mi piace separare ogni gestore di eventi in una funzione dedicata.
Inizieremo con l'evento `TimerStarted`.

<TimerBlocOnStartedSnippet />

Se il `TimerBloc` riceve un evento `TimerStarted`, emette uno
stato `TimerRunInProgress` con la durata iniziale. Inoltre, se c'era
già una `_tickerSubscription` aperta dobbiamo cancellarla per deallocare la
memoria. Dobbiamo anche sovrascrivere il metodo `close` sul nostro `TimerBloc` così che
possiamo cancellare la `_tickerSubscription` quando il `TimerBloc` è chiuso. Infine,
ascoltiamo lo stream `_ticker.tick` e su ogni tick aggiungiamo un evento `_TimerTicked`
con la durata rimanente.

Successivamente, implementiamo il gestore di eventi `_TimerTicked`.

<TimerBlocOnTickedSnippet />

Ogni volta che viene ricevuto un evento `_TimerTicked`, se la durata del tick è maggiore
di 0, dobbiamo emettere uno stato `TimerRunInProgress` aggiornato con la nuova
durata. Altrimenti, se la durata del tick è 0, il nostro timer è terminato e dobbiamo
emettere uno stato `TimerRunComplete`.

Ora implementiamo il gestore di eventi `TimerPaused`.

<TimerBlocOnPausedSnippet />

In `_onPaused` se lo `state` del nostro `TimerBloc` è `TimerRunInProgress`, allora
possiamo mettere in pausa la `_tickerSubscription` ed emettere uno stato `TimerRunPause` con la
durata del timer corrente.

Successivamente, implementiamo il gestore di eventi `TimerResumed` così possiamo riprendere
il timer.

<TimerBlocOnResumedSnippet />

Il gestore di eventi `TimerResumed` è molto simile al gestore di eventi `TimerPaused`. Se il `TimerBloc` ha uno
`state` di `TimerRunPause` e riceve un evento `TimerResumed`, riprende la `_tickerSubscription` ed emette uno
stato `TimerRunInProgress` con la durata corrente.

Infine, dobbiamo implementare il gestore di eventi `TimerReset`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/timer/bloc/timer_bloc.dart"
	title="lib/timer/bloc/timer_bloc.dart"
/>

Se il `TimerBloc` riceve un evento `TimerReset`, deve cancellare la corrente
`_tickerSubscription` così che non viene notificato di tick aggiuntivi ed
emette uno stato `TimerInitial` con la durata originale.

Questo è tutto per il `TimerBloc`. Ora tutto ciò che resta è implementare l'UI
per il nostro Timer.

## UI dell'Applicazione

### MyApp

Possiamo iniziare cancellando il contenuto di `main.dart` e sostituendolo con
il seguente.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/main.dart"
	title="lib/main.dart"
/>

Successivamente, creiamo il nostro widget `App` in `app.dart`, che sarà la radice della nostra
applicazione.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/app.dart"
	title="lib/app.dart"
/>

Successivamente, dobbiamo implementare il nostro widget `Timer`.

### Timer

Il nostro widget `Timer` (`lib/timer/view/timer_page.dart`) sarà responsabile di
visualizzare il tempo rimanente insieme ai pulsanti appropriati che permetteranno
agli utenti di avviare, mettere in pausa e resettare il timer.

<TimerPageSnippet />

Finora, stiamo solo usando `BlocProvider` per accedere all'istanza del nostro
`TimerBloc`.

Successivamente, implementeremo il nostro widget `Actions` che avrà le
azioni appropriate (avvia, pausa e reset).

### Barrel

Per pulire i nostri import dalla sezione `Timer`, dobbiamo creare un file "barrel"
`timer/timer.dart`.

<RemoteCode
	url="https://raw.githubusercontent.com/felangel/bloc/master/examples/flutter_timer/lib/timer/timer.dart"
	title="lib/timer/timer.dart"
/>

### Actions

<ActionsSnippet />

Il widget `Actions` è solo un altro `StatelessWidget` che usa un
`BlocBuilder` per ricostruire la UI ogni volta che otteniamo un nuovo `TimerState`. `Actions`
usa `context.read<TimerBloc>()` per accedere all'istanza del `TimerBloc` e restituisce
diversi `FloatingActionButtons` in base allo stato corrente del `TimerBloc`.
Ognuno dei `FloatingActionButtons` aggiunge un evento nel suo callback `onPressed` per
notificare il `TimerBloc`.

Se vuoi un controllo granulare su quando la funzione `builder` viene chiamata puoi
fornire opzionalmente un `buildWhen` a `BlocBuilder`. Il `buildWhen` prende lo stato precedente del bloc e lo stato corrente del bloc e restituisce un `booleano`. Se
`buildWhen` restituisce `true`, `builder` sarà chiamato con `state` e il widget
si ricostruirà. Se `buildWhen` restituisce `false`, `builder` non sarà chiamato con
`state` e non si verificherà alcun aggiornamento.

In questo caso, non vogliamo che il widget `Actions` sia ricostruito su ogni tick
perché sarebbe inefficiente. Invece, vogliamo che `Actions` si ricostruisca solo se
il `runtimeType` del `TimerState` cambia (TimerInitial =>
TimerRunInProgress, TimerRunInProgress => TimerRunPause, ecc...).

Di conseguenza, se colorassimo casualmente i widget su ogngli aggiornamenti, sarebbe:

![BlocBuilder buildWhen demo](https://cdn-images-1.medium.com/max/1600/1*YyjpH1rcZlYWxCX308l_Ew.gif)

:::note

Anche se il widget `Text` è ricostruito su ogni tick, ricostruiamo le
`Actions` solo se necessario.

:::

### Background

Infine, aggiungi il widget background come segue:

<BackgroundSnippet />

### Riassumendo

Questo è tutto! A questo punto abbiamo un'applicazione timer abbastanza solida
che ricostruisce efficientemente i widget solo quando necessario.

Il codice sorgente completo per questo esempio può essere trovato
[qui](https://github.com/felangel/Bloc/tree/master/examples/flutter_timer).
