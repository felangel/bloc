---
title: FAQ
description: Risposte alle domande frequenti riguardo la libreria bloc.
---

import StateNotUpdatingGood1Snippet from '~/components/faqs/StateNotUpdatingGood1Snippet.astro';
import StateNotUpdatingGood2Snippet from '~/components/faqs/StateNotUpdatingGood2Snippet.astro';
import StateNotUpdatingGood3Snippet from '~/components/faqs/StateNotUpdatingGood3Snippet.astro';
import StateNotUpdatingBad1Snippet from '~/components/faqs/StateNotUpdatingBad1Snippet.astro';
import StateNotUpdatingBad2Snippet from '~/components/faqs/StateNotUpdatingBad2Snippet.astro';
import StateNotUpdatingBad3Snippet from '~/components/faqs/StateNotUpdatingBad3Snippet.astro';
import EquatableEmitSnippet from '~/components/faqs/EquatableEmitSnippet.astro';
import EquatableBlocTestSnippet from '~/components/faqs/EquatableBlocTestSnippet.astro';
import NoEquatableBlocTestSnippet from '~/components/faqs/NoEquatableBlocTestSnippet.astro';
import SingleStateSnippet from '~/components/faqs/SingleStateSnippet.astro';
import SingleStateUsageSnippet from '~/components/faqs/SingleStateUsageSnippet.astro';
import BlocProviderGood1Snippet from '~/components/faqs/BlocProviderGood1Snippet.astro';
import BlocProviderGood2Snippet from '~/components/faqs/BlocProviderGood2Snippet.astro';
import BlocProviderBad1Snippet from '~/components/faqs/BlocProviderBad1Snippet.astro';
import BlocInternalAddEventSnippet from '~/components/faqs/BlocInternalAddEventSnippet.astro';
import BlocInternalEventSnippet from '~/components/faqs/BlocInternalEventSnippet.astro';
import BlocExternalForEachSnippet from '~/components/faqs/BlocExternalForEachSnippet.astro';

## Lo stato non si aggiorna

‚ùî **Domanda**: Sto emettendo uno stato nel mio bloc ma l'interfaccia utente non
si aggiorna. Cosa sto sbagliando?

üí° **Risposta**: Se stai usando Equatable assicurati di passare tutte le
propriet√† al getter `props`.

‚úÖ **Buono**

<StateNotUpdatingGood1Snippet />

‚ùå **Errato**

<StateNotUpdatingBad1Snippet />

<StateNotUpdatingBad2Snippet />

Inoltre, assicurati di emettere una nuova istanza dello stato nel tuo bloc.

‚úÖ **Buono**

<StateNotUpdatingGood2Snippet />

<StateNotUpdatingGood3Snippet />

‚ùå **Errato**

<StateNotUpdatingBad3Snippet />

:::caution

Le propriet√† `Equatable` dovrebbero sempre essere copiate piuttosto che
modificate. Se una classe `Equatable` contiene una `List` o `Map` come
propriet√†, assicurati di usare `List.of` o `Map.of` rispettivamente per
assicurarti che l'uguaglianza sia valutata in base ai valori delle propriet√†
piuttosto che al riferimento.

:::

## Quando Usare Equatable

‚ùî**Domanda**: Quando dovrei usare Equatable?

üí°**Risposta**:

<EquatableEmitSnippet />

Nello scenario sopra, se `StateA` estende `Equatable` si verificher√† solo un
cambiamento di stato (la seconda emissione sar√† ignorata). In generale, dovresti
usare `Equatable` se vuoi ottimizzare il tuo codice per ridurre il numero di
aggiornamenti. Non dovresti usare `Equatable` se vuoi che lo stesso stato
consecutivo attivi pi√π transizioni.

Inoltre, usare `Equatable` rende molto pi√π facile testare i bloc poich√© possiamo
aspettarci istanze specifiche degli stati del bloc piuttosto che usare
`Matchers` o `Predicates`.

<EquatableBlocTestSnippet />

Senza `Equatable` il test sopra fallirebbe e dovrebbe essere riscritto cos√¨:

<NoEquatableBlocTestSnippet />

## Gestione degli Errori

‚ùî **Domanda**: Come posso gestire un errore continuando a mostrare i dati
precedenti?

üí° **Risposta**:

Questo dipende molto da come lo stato del bloc √® stato modellato. Nei casi in
cui i dati dovrebbero essere conservati anche in presenza di un errore,
considera l'uso di una singola classe per lo stato.

<SingleStateSnippet />

Questo permetter√† ai widget di avere accesso alle propriet√† `data` e `error`
contemporaneamente e il bloc pu√≤ usare `state.copyWith` per conservare i vecchi
dati anche quando si √® verificato un errore.

<SingleStateUsageSnippet />

## Bloc vs. Redux

‚ùî **Domanda**: Qual √® la differenza tra Bloc e Redux?

üí° **Risposta**:

BLoC √® un modello di progettazione basato sulle seguenti regole:

1. Input e Output del BLoC sono semplici Stream e Sink;
2. Le dipendenze devono essere iniettabili e indipendenti dalla piattaforma;
3. Non √® consentita alcuna ramificazione sulla base della piattaforma;
4. L'implementazione pu√≤ essere qualsiasi cosa tu voglia purch√© segua le regole
   sopra indicate.

Le linee guida UI sono:

1. Ogni componente "abbastanza complesso" ha un BLoC corrispondente;
2. I componenti dovrebbero inviare input "cos√¨ come sono" (non deve elaborare,
   filtrare o trasformare il dato);
3. I componenti dovrebbero mostrare output il pi√π vicino possibile a "cos√¨ come
   sono";
4. Tutto il branching dovrebbe essere basato su semplici output booleani del
   BLoC.

La libreria Bloc implementa il modello BLoC e mira ad astrarre RxDart per
semplificare l'esperienza dello sviluppatore.

I tre principi di Redux sono:

1. Singola fonte di verit√†;
2. Lo stato √® read-only;
3. I cambiamenti sono fatti con funzioni pure.

La libreria bloc viola il primo principio; con bloc lo stato √® distribuito
attraverso pi√π bloc. Inoltre, non c'√® il concetto di middleware in bloc e bloc √®
progettato per facilitare i cambiamenti di stato in modo asincrono,
permettendoti di emettere pi√π stati per un singolo evento.

## Bloc vs. Provider

‚ùî **Domanda**: Qual √® la differenza tra Bloc e Provider?

üí° **Risposta**: `provider` √® progettato per la dependency injection ("wrapper"
attorno a `InheritedWidget`). Devi ancora capire come gestire il tuo stato
(tramite `ChangeNotifier`, `Bloc`, `Mobx`, ecc...). La libreria Bloc usa
`provider` internamente per rendere facile fornire e accedere ai bloc in tutto
l'albero dei widget.

## BlocProvider.of() Non Trova il Bloc

‚ùî **Domanda**: Quando uso `BlocProvider.of(context)` non riesce a trovare il
bloc, come posso risolverlo?

üí° **Risposta**: Non puoi accedere a un bloc dallo stesso contesto in cui √®
stato fornito (provide) quindi devi assicurarti che `BlocProvider.of()` sia
chiamato all'interno di un `BuildContext` figlio.

‚úÖ **Buono**

<BlocProviderGood1Snippet />

<BlocProviderGood2Snippet />

‚ùå **Errato**

<BlocProviderBad1Snippet />

## Struttura del Progetto

‚ùî **Domanda**: Come dovrei strutturare il mio progetto?

üí° **Risposta**: Anche se non c'√® davvero una risposta giusta/sbagliata a questa
domanda, questi sono dei riferimenti che possono risponderti:

- [I/O Photobooth](https://github.com/flutter/photobooth);
- [I/O Pinball](https://github.com/flutter/pinball);
- [Flutter News Toolkit](https://github.com/flutter/news_toolkit).

La cosa pi√π importante √® avere una struttura del progetto **consistente** e
**ben definita**.

## Aggiungere Eventi all'Interno di un Bloc

‚ùî **Domanda**: Va bene aggiungere eventi all'interno di un bloc?

üí° **Risposta**: Nella maggior parte dei casi, gli eventi dovrebbero essere
aggiunti esternamente ma in alcuni casi particolari pu√≤ avere senso.

La situazione pi√π comune in cui vengono usati eventi interni √® quando i
cambiamenti di stato devono verificarsi in risposta ad aggiornamenti in tempo
reale da un repository. In queste situazioni, il repository √® lo stimolo per il
cambiamento di stato invece di un evento esterno come il tocco di un pulsante.

Nell'esempio seguente, lo stato di `MyBloc` dipende dall'utente corrente che √®
esposto tramite lo `Stream<User>` dal `UserRepository`. `MyBloc` ascolta i
cambiamenti nell'utente corrente e aggiunge un evento interno `_UserChanged`
ogni volta che un utente viene emesso dallo stream degli utenti.

<BlocInternalAddEventSnippet />

Aggiungendo un evento interno, siamo anche in grado di specificare un
`transformer` personalizzato per l'evento per determinare come pi√π eventi
`_UserChanged` saranno processati -- di default saranno processati
concorrentemente.

√à altamente raccomandato che gli eventi interni siano privati. Questo √® un modo
esplicito di segnalare che un evento specifico √® usato solo all'interno del bloc
stesso e previene che i componenti esterni conoscano l'evento.

<BlocInternalEventSnippet />

Possiamo alternativamente definire un evento esterno `Started` e usare l'API
`emit.forEach` per gestire la reazione agli aggiornamenti degli utenti in tempo
reale:

<BlocExternalForEachSnippet />

I vantaggi dell'approccio sopra sono:

- Non abbiamo bisogno di un evento interno `_UserChanged`;
- Non abbiamo bisogno di gestire manualmente la `StreamSubscription`;
- Abbiamo pieno controllo su quando il bloc si sottoscrive allo stream degli
  aggiornamenti degli utenti.

Gli svantaggi dell'approccio sopra sono:

- Non possiamo facilmente mettere in pausa (`pause`) o riprendere (`resume`) la
  sottoscrizione;
- Dobbiamo esporre un evento pubblico `Started` che poi sar√† da emittare
  esternamente;
- Non possiamo usare un `transformer` personalizzato per regolare come reagiamo
  agli aggiornamenti degli utenti.

## Esporre Metodi Pubblici

‚ùî **Domanda**: Va bene esporre metodi pubblici sulle mie istanze di bloc e
cubit?

üí° **Risposta**

Quando crei un cubit, √® raccomandato esporre metodi pubblici solo per attivare
dei cambiamenti di stato. Di conseguenza, generalmente tutti i metodi pubblici
su un'istanza di cubit dovrebbero restituire `void` o `Future<void>`.

Quando crei un bloc, √® raccomandato evitare di esporre qualsiasi metodo pubblico
personalizzato mentre √® corretto notificare il bloc degli eventi chiamando
`add`.
