---
title: FAQ
description: R√©ponses aux questions fr√©quemment pos√©es sur la biblioth√®que bloc.
---

import StateNotUpdatingGood1Snippet from '~/components/faqs/StateNotUpdatingGood1Snippet.astro';
import StateNotUpdatingGood2Snippet from '~/components/faqs/StateNotUpdatingGood2Snippet.astro';
import StateNotUpdatingGood3Snippet from '~/components/faqs/StateNotUpdatingGood3Snippet.astro';
import StateNotUpdatingBad1Snippet from '~/components/faqs/StateNotUpdatingBad1Snippet.astro';
import StateNotUpdatingBad2Snippet from '~/components/faqs/StateNotUpdatingBad2Snippet.astro';
import StateNotUpdatingBad3Snippet from '~/components/faqs/StateNotUpdatingBad3Snippet.astro';
import EquatableEmitSnippet from '~/components/faqs/EquatableEmitSnippet.astro';
import EquatableBlocTestSnippet from '~/components/faqs/EquatableBlocTestSnippet.astro';
import NoEquatableBlocTestSnippet from '~/components/faqs/NoEquatableBlocTestSnippet.astro';
import SingleStateSnippet from '~/components/faqs/SingleStateSnippet.astro';
import SingleStateUsageSnippet from '~/components/faqs/SingleStateUsageSnippet.astro';
import BlocProviderGood1Snippet from '~/components/faqs/BlocProviderGood1Snippet.astro';
import BlocProviderGood2Snippet from '~/components/faqs/BlocProviderGood2Snippet.astro';
import BlocProviderBad1Snippet from '~/components/faqs/BlocProviderBad1Snippet.astro';
import BlocInternalAddEventSnippet from '~/components/faqs/BlocInternalAddEventSnippet.astro';
import BlocInternalEventSnippet from '~/components/faqs/BlocInternalEventSnippet.astro';
import BlocExternalForEachSnippet from '~/components/faqs/BlocExternalForEachSnippet.astro';

## L'√âtat ne se Met pas √† Jour

‚ùî **Question** : J'√©mets un √©tat dans mon bloc mais l'interface utilisateur ne
se met pas √† jour. Qu'est-ce que je fais de mal ?

üí° **R√©ponse** : Si vous utilisez Equatable, assurez-vous de passer toutes les
propri√©t√©s au getter props.

‚úÖ **BON**

<StateNotUpdatingGood1Snippet />

‚ùå **MAUVAIS**

<StateNotUpdatingBad1Snippet />

<StateNotUpdatingBad2Snippet />

De plus, assurez-vous d'√©mettre une nouvelle instance de l'√©tat dans votre bloc.

‚úÖ **BON**

<StateNotUpdatingGood2Snippet />

<StateNotUpdatingGood3Snippet />

‚ùå **MAUVAIS**

<StateNotUpdatingBad3Snippet />

:::caution

Les propri√©t√©s d'`Equatable` doivent toujours √™tre copi√©es plut√¥t que modifi√©es.
Si une classe `Equatable` contient une `List` ou `Map` comme propri√©t√©s,
assurez-vous d'utiliser `List.of` ou `Map.of` respectivement pour garantir que
l'√©galit√© soit √©valu√©e en fonction des valeurs des propri√©t√©s plut√¥t que de la
r√©f√©rence.

:::

## Quand Utiliser Equatable

‚ùî**Question** : Quand dois-je utiliser Equatable ?

üí°**R√©ponse** :

<EquatableEmitSnippet />

Dans le sc√©nario ci-dessus, si `StateA` √©tend `Equatable`, un seul changement
d'√©tat se produira (le second emit sera ignor√©). En g√©n√©ral, vous devriez
utiliser `Equatable` si vous souhaitez optimiser votre code pour r√©duire le
nombre de reconstructions. Vous ne devriez pas utiliser `Equatable` si vous
souhaitez que le m√™me √©tat cons√©cutif d√©clenche plusieurs transitions.

De plus, l'utilisation d'`Equatable` facilite beaucoup les tests de blocs, car
nous pouvons attendre des instances sp√©cifiques d'√©tats de bloc au lieu
d'utiliser `Matchers` ou `Predicates`.

<EquatableBlocTestSnippet />

Sans `Equatable`, le test ci-dessus √©chouerait et devrait √™tre r√©√©crit ainsi :

<NoEquatableBlocTestSnippet />

## Gestion des Erreurs

‚ùî **Question** : Comment puis-je g√©rer une erreur tout en continuant √† afficher
les donn√©es pr√©c√©dentes ?

üí° **R√©ponse** :

Cela d√©pend fortement de la fa√ßon dont l'√©tat du bloc a √©t√© mod√©lis√©. Dans les
cas o√π les donn√©es doivent √™tre conserv√©es m√™me en pr√©sence d'une erreur,
envisagez d'utiliser une seule classe d'√©tat.

<SingleStateSnippet />

Cela permettra aux widgets d'avoir acc√®s aux propri√©t√©s `data` et `error`
simultan√©ment et le bloc peut utiliser `state.copyWith` pour conserver les
anciennes donn√©es m√™me lorsqu'une erreur se produit.

<SingleStateUsageSnippet />

## Bloc vs. Redux

‚ùî **Question** : Quelle est la diff√©rence entre Bloc et Redux ?

üí° **R√©ponse** :

BLoC est un mod√®le de conception qui se d√©finit par les r√®gles suivantes :

1. L'entr√©e et la sortie du BLoC sont des Streams et Sinks simples.
2. Les d√©pendances doivent √™tre injectables et agnostiques de la plateforme.
3. Aucune bifurcation de plateforme n'est autoris√©e.
4. L'impl√©mentation peut √™tre ce que vous voulez tant que vous suivez les r√®gles
   ci-dessus.

Les directives de l'interface utilisateur sont :

1. Chaque composant "suffisamment complexe" a un BLoC correspondant.
2. Les composants doivent envoyer les entr√©es "telles quelles".
3. Les composants doivent afficher les sorties aussi pr√®s de "telles quelles"
   que possible.
4. Toute bifurcation doit √™tre bas√©e sur des sorties bool√©ennes simples du BLoC.

La biblioth√®que Bloc impl√©mente le mod√®le de conception BLoC et vise √† abstraire
RxDart pour simplifier l'exp√©rience du d√©veloppeur.

Les trois principes de Redux sont :

1. Source unique de v√©rit√©
2. L'√©tat est en lecture seule
3. Les changements sont effectu√©s avec des fonctions pures

La biblioth√®que bloc viole le premier principe ; avec bloc, l'√©tat est distribu√©
√† travers plusieurs blocs. De plus, il n'y a pas de concept de middleware dans
bloc et bloc est con√ßu pour faciliter les changements d'√©tat asynchrones, vous
permettant d'√©mettre plusieurs √©tats pour un seul √©v√©nement.

## Bloc vs. Provider

‚ùî **Question** : Quelle est la diff√©rence entre Bloc et Provider ?

üí° **R√©ponse** : `provider` est con√ßu pour l'injection de d√©pendances (il
encapsule `InheritedWidget`). Vous devez toujours d√©terminer comment g√©rer votre
√©tat (via `ChangeNotifier`, `Bloc`, `Mobx`, etc...). La biblioth√®que Bloc
utilise `provider` en interne pour faciliter la fourniture et l'acc√®s aux blocs
dans l'arbre de widgets.

## BlocProvider.of() ne Trouve pas le Bloc

‚ùî **Question** : Lorsque j'utilise `BlocProvider.of(context)`, il ne peut pas
trouver le bloc. Comment puis-je r√©soudre ce probl√®me ?

üí° **R√©ponse** : Vous ne pouvez pas acc√©der √† un bloc √† partir du m√™me contexte
dans lequel il a √©t√© fourni, vous devez donc vous assurer que `BlocProvider.of()`
est appel√© dans un `BuildContext` enfant.

‚úÖ **BON**

<BlocProviderGood1Snippet />

<BlocProviderGood2Snippet />

‚ùå **MAUVAIS**

<BlocProviderBad1Snippet />

## Structure du Projet

‚ùî **Question** : Comment dois-je structurer mon projet ?

üí° **R√©ponse** : Bien qu'il n'y ait vraiment pas de bonne/mauvaise r√©ponse √†
cette question, voici quelques r√©f√©rences recommand√©es :

- [I/O Photobooth](https://github.com/flutter/photobooth)
- [I/O Pinball](https://github.com/flutter/pinball)
- [Flutter News Toolkit](https://github.com/flutter/news_toolkit)

Le plus important est d'avoir une structure de projet **coh√©rente** et
**intentionnelle**.

## Ajouter des √âv√©nements dans un Bloc

‚ùî **Question** : Est-il acceptable d'ajouter des √©v√©nements √† l'int√©rieur d'un
bloc ?

üí° **R√©ponse** : Dans la plupart des cas, les √©v√©nements doivent √™tre ajout√©s
en externe, mais dans certains cas s√©lectionn√©s, il peut √™tre judicieux que les
√©v√©nements soient ajout√©s en interne.

La situation la plus courante o√π les √©v√©nements internes sont utilis√©s est
lorsque les changements d'√©tat doivent se produire en r√©ponse √† des mises √† jour
en temps r√©el depuis un d√©p√¥t. Dans ces situations, le d√©p√¥t est le stimulus
pour le changement d'√©tat plut√¥t qu'un √©v√©nement externe comme un appui sur un
bouton.

Dans l'exemple suivant, l'√©tat de `MyBloc` d√©pend de l'utilisateur actuel qui
est expos√© via le `Stream<User>` du `UserRepository`. `MyBloc` √©coute les
changements de l'utilisateur actuel et ajoute un √©v√©nement interne `_UserChanged`
chaque fois qu'un utilisateur est √©mis depuis le flux d'utilisateurs.

<BlocInternalAddEventSnippet />

Lors de l'ajout d'un √©v√©nement interne, nous pouvons √©galement sp√©cifier un
`transformer` personnalis√© pour l'√©v√©nement afin de d√©terminer comment plusieurs
√©v√©nements `_UserChanged` seront trait√©s -- par d√©faut, ils seront trait√©s
simultan√©ment.

Il est fortement recommand√© que les √©v√©nements internes soient priv√©s. C'est une
fa√ßon explicite de signaler qu'un √©v√©nement sp√©cifique est utilis√© uniquement √†
l'int√©rieur du bloc et emp√™che les composants externes de conna√Ætre l'√©v√©nement.

<BlocInternalEventSnippet />

Alternativement, nous pouvons d√©finir un √©v√©nement externe `Started` et utiliser
l'API `emit.forEach` pour g√©rer la r√©action aux mises √† jour des utilisateurs en
temps r√©el :

<BlocExternalForEachSnippet />

Les avantages de l'approche ci-dessus sont :

- Nous n'avons pas besoin d'un √©v√©nement interne `_UserChanged`
- Nous n'avons pas besoin de g√©rer manuellement la `StreamSubscription`
- Nous avons un contr√¥le total sur quand le bloc s'abonne au flux de mises √†
  jour des utilisateurs

Les inconv√©nients de l'approche ci-dessus sont :

- Nous ne pouvons pas facilement `pausar` ou `reprendre` l'abonnement
- Nous devons exposer un √©v√©nement public `Started` qui doit √™tre ajout√© en
  externe
- Nous ne pouvons pas utiliser un `transformer` personnalis√© pour ajuster la
  fa√ßon dont nous r√©agissons aux mises √† jour des utilisateurs

## Exposer des M√©thodes Publiques

‚ùî **Question** : Est-il acceptable d'exposer des m√©thodes publiques sur mes
instances de bloc et cubit ?

üí° **R√©ponse**

Lors de la cr√©ation d'un cubit, il est recommand√© d'exposer uniquement des
m√©thodes publiques dans le but de d√©clencher des changements d'√©tat. Par
cons√©quent, g√©n√©ralement toutes les m√©thodes publiques sur une instance de cubit
doivent retourner `void` ou `Future<void>`.

Lors de la cr√©ation d'un bloc, il est recommand√© d'√©viter d'exposer des m√©thodes
publiques personnalis√©es et de plut√¥t notifier le bloc d'√©v√©nements en appelant
`add`.
